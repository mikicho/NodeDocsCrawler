<h2>URL - v10.0.0</h2><p>The WHATWG <code>URL</code> class. See the <a href="url.html#url_class_url"><code>URL</code></a> section.</p>
<h2>URLSearchParams - v10.0.0</h2><p>The WHATWG <code>URLSearchParams</code> class. See the <a href="#url_class_urlsearchparams"><code>URLSearchParams</code></a> section.</p>
<!-- [end-include:globals.md] -->
<!-- [start-include:http.md] -->
<h2>hasUncaughtExceptionCaptureCallback - v9.3.0</h2><p>Indicates whether a callback has been set using
<a href="process.html#process_process_setuncaughtexceptioncapturecallback_fn"><code>process.setUncaughtExceptionCaptureCallback()</code></a>.</p>
<h2>setUncaughtExceptionCaptureCallback - v9.3.0</h2><p>The <code>process.setUncaughtExceptionCapture</code> function sets a function that will
be invoked when an uncaught exception occurs, which will receive the exception
value itself as its first argument.</p>
<p>If such a function is set, the <a href="process.html#process_event_uncaughtexception"><code>&#39;uncaughtException&#39;</code></a> event will
not be emitted. If <code>--abort-on-uncaught-exception</code> was passed from the
command line or set through <a href="v8.html#v8_v8_setflagsfromstring_flags"><code>v8.setFlagsFromString()</code></a>, the process will
not abort.</p>
<p>To unset the capture function, <code>process.setUncaughtExceptionCapture(null)</code>
may be used. Calling this method with a non-<code>null</code> argument while another
capture function is set will throw an error.</p>
<p>Using this function is mutually exclusive with using the deprecated
<a href="domain.html"><code>domain</code></a> built-in module.</p>
<h2>napi_fatal_exception - v9.10.0</h2><pre><code class="lang-C">napi_status napi_fatal_exception(napi_env env, napi_value err);
</code></pre>
<ul>
<li><code>[in] env</code>: The environment that the API is invoked under.</li>
<li><code>[in] err</code>: The error you want to pass to <code>&#39;uncaughtException&#39;</code>.</li>
</ul>
<p>Trigger an <code>&#39;uncaughtException&#39;</code> in JavaScript. Useful if an async
callback throws an exception with no way to recover.</p>
<h2>napi_add_env_cleanup_hook - v10.2.0</h2><pre><code class="lang-C">NODE_EXTERN napi_status napi_add_env_cleanup_hook(napi_env env,
                                                  void (*fun)(void* arg),
                                                  void* arg);
</code></pre>
<p>Registers <code>fun</code> as a function to be run with the <code>arg</code> parameter once the
current Node.js environment exits.</p>
<p>A function can safely be specified multiple times with different
<code>arg</code> values. In that case, it will be called multiple times as well.
Providing the same <code>fun</code> and <code>arg</code> values multiple times is not allowed
and will lead the process to abort.</p>
<p>The hooks will be called in reverse order, i.e. the most recently added one
will be called first.</p>
<p>Removing this hook can be done by using <code>napi_remove_env_cleanup_hook</code>.
Typically, that happens when the resource for which this hook was added
is being torn down anyway.</p>
<h2>napi_remove_env_cleanup_hook - v10.2.0</h2><pre><code class="lang-C">NAPI_EXTERN napi_status napi_remove_env_cleanup_hook(napi_env env,
                                                     void (*fun)(void* arg),
                                                     void* arg);
</code></pre>
<p>Unregisters <code>fun</code> as a function to be run with the <code>arg</code> parameter once the
current Node.js environment exits. Both the argument and the function value
need to be exact matches.</p>
<p>The function must have originally been registered
with <code>napi_add_env_cleanup_hook</code>, otherwise the process will abort.</p>
<h2>napi_open_callback_scope - v9.6.0</h2><pre><code class="lang-C">NAPI_EXTERN napi_status napi_open_callback_scope(napi_env env,
                                                 napi_value resource_object,
                                                 napi_async_context context,
                                                 napi_callback_scope* result)
</code></pre>
<ul>
<li><code>[in] env</code>: The environment that the API is invoked under.</li>
<li><code>[in] resource_object</code>: An optional object associated with the async work
that will be passed to possible <code>async_hooks</code> <a href="async_hooks.html#async_hooks_init_asyncid_type_triggerasyncid_resource"><code>init</code> hooks</a>.</li>
<li><code>[in] context</code>: Context for the async operation that is
invoking the callback. This should be a value previously obtained
from <a href="#n_api_napi_async_init"><code>napi_async_init</code></a>.</li>
<li><code>[out] result</code>: The newly created scope.</li>
</ul>
<p>There are cases (for example resolving promises) where it is
necessary to have the equivalent of the scope associated with a callback
in place when making certain N-API calls. If there is no other script on
the stack the <a href="#n_api_napi_open_callback_scope"><code>napi_open_callback_scope</code></a> and
<a href="#n_api_napi_close_callback_scope"><code>napi_close_callback_scope</code></a> functions can be used to open/close
the required scope.</p>
<h2>napi_close_callback_scope - v9.6.0</h2><pre><code class="lang-C">NAPI_EXTERN napi_status napi_close_callback_scope(napi_env env,
                                                  napi_callback_scope scope)
</code></pre>
<ul>
<li><code>[in] env</code>: The environment that the API is invoked under.</li>
<li><code>[in] scope</code>: The scope to be closed.</li>
</ul>
<p>This API can be called even if there is a pending JavaScript exception.</p>
<h2>napi_get_uv_event_loop - v9.3.0</h2><pre><code class="lang-C">NAPI_EXTERN napi_status napi_get_uv_event_loop(napi_env env,
                                               uv_loop_t** loop);
</code></pre>
<ul>
<li><code>[in] env</code>: The environment that the API is invoked under.</li>
<li><code>[out] loop</code>: The current libuv loop instance.</li>
</ul>
<!-- [end-include:n-api.md] -->
<!-- [start-include:child_process.md] -->
<h2>`--experimental-repl-await` - v10.0.0</h2><p>Enable experimental top-level <code>await</code> keyword support in REPL.</p>
<h2>`--experimental-vm-modules` - v9.6.0</h2><p>Enable experimental ES Module support in the <code>vm</code> module.</p>
<h2>`--preserve-symlinks-main` - v10.2.0</h2><p>Instructs the module loader to preserve symbolic links when resolving and
caching the main module (<code>require.main</code>).</p>
<p>This flag exists so that the main module can be opted-in to the same behavior
that <code>--preserve-symlinks</code> gives to all other imports; they are separate flags,
however, for backward compatibility with older Node.js versions.</p>
<p>Note that <code>--preserve-symlinks-main</code> does not imply <code>--preserve-symlinks</code>; it
is expected that <code>--preserve-symlinks-main</code> will be used in addition to
<code>--preserve-symlinks</code> when it is not desirable to follow symlinks before
resolving relative paths.</p>
<p>See <code>--preserve-symlinks</code> for more information.</p>
<h2>`--trace-event-file-pattern` - v9.8.0</h2><p>Template string specifying the filepath for the trace event data, it
supports <code>${rotation}</code> and <code>${pid}</code>.</p>
<h2>`-c`,_`--check` - v10.0.0</h2><p>Syntax check the script without executing.</p>
<h2>strict_mode - v9.9.0</h2><p>When using the <code>strict mode</code>, any <code>assert</code> function will use the equality used
in the strict function mode. So <a href="#assert_assert_deepequal_actual_expected_message"><code>assert.deepEqual()</code></a> will, for example,
work the same as <a href="assert.html#assert_assert_deepstrictequal_actual_expected_message"><code>assert.deepStrictEqual()</code></a>.</p>
<p>On top of that, error messages which involve objects produce an error diff
instead of displaying both objects. That is not the case for the legacy mode.</p>
<p>It can be accessed using:</p>
<pre><code class="lang-js">const assert = require(&#39;assert&#39;).strict;
</code></pre>
<p>Example error diff:</p>
<pre><code class="lang-js">const assert = require(&#39;assert&#39;).strict;

assert.deepEqual([[[1, 2, 3]], 4, 5], [[[1, 2, &#39;3&#39;]], 4, 5]);
// AssertionError: Input A expected to strictly deep-equal input B:
// + expected - actual ... Lines skipped
//
//   [
//     [
// ...
//       2,
// -     3
// +     &#39;3&#39;
//     ],
// ...
//     5
//   ]
</code></pre>
<p>To deactivate the colors, use the <code>NODE_DISABLE_COLORS</code> environment variable.
Please note that this will also deactivate the colors in the REPL.</p>
<h2>doesNotReject - v10.0.0</h2><p>Awaits the <code>block</code> promise or, if <code>block</code> is a function, immediately calls the
function and awaits the returned promise to complete. It will then check that
the promise is not rejected.</p>
<p>If <code>block</code> is a function and it throws an error synchronously,
<code>assert.doesNotReject()</code> will return a rejected <code>Promise</code> with that error. If
the function does not return a promise, <code>assert.doesNotReject()</code> will return a
rejected <code>Promise</code> with an <a href="errors.html#errors_err_invalid_return_value"><code>ERR_INVALID_RETURN_VALUE</code></a> error. In both cases
the error handler is skipped.</p>
<p>Please note: Using <code>assert.doesNotReject()</code> is actually not useful because there
is little benefit by catching a rejection and then rejecting it again. Instead,
consider adding a comment next to the specific code path that should not reject
and keep error messages as expressive as possible.</p>
<p>If specified, <code>error</code> can be a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes"><code>Class</code></a>, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions"><code>RegExp</code></a> or a validation
function. See <a href="#assert_assert_throws_block_error_message"><code>assert.throws()</code></a> for more details.</p>
<p>Besides the async nature to await the completion behaves identically to
<a href="#assert_assert_doesnotthrow_block_error_message"><code>assert.doesNotThrow()</code></a>.</p>
<pre><code class="lang-js">(async () =&gt; {
  await assert.doesNotReject(
    async () =&gt; {
      throw new TypeError(&#39;Wrong value&#39;);
    },
    SyntaxError
  );
})();
</code></pre>
<pre><code class="lang-js">assert.doesNotReject(Promise.reject(new TypeError(&#39;Wrong value&#39;)))
  .then(() =&gt; {
    // ...
  });
</code></pre>
<h2>fail - v10.0.0</h2><p>Stability: 0 - Deprecated: Use <code>assert.fail([message])</code> or other assert
functions instead.</p>
<p>If <code>message</code> is falsy, the error message is set as the values of <code>actual</code> and
<code>expected</code> separated by the provided <code>operator</code>. If just the two <code>actual</code> and
<code>expected</code> arguments are provided, <code>operator</code> will default to <code>&#39;!=&#39;</code>. If
<code>message</code> is provided as third argument it will be used as the error message and
the other arguments will be stored as properties on the thrown object. If
<code>stackStartFunction</code> is provided, all stack frames above that function will be
removed from stacktrace (see <a href="errors.html#errors_error_capturestacktrace_targetobject_constructoropt"><code>Error.captureStackTrace</code></a>). If no arguments are
given, the default message <code>Failed</code> will be used.</p>
<pre><code class="lang-js">const assert = require(&#39;assert&#39;).strict;

assert.fail(&#39;a&#39;, &#39;b&#39;);
// AssertionError [ERR_ASSERTION]: &#39;a&#39; != &#39;b&#39;

assert.fail(1, 2, undefined, &#39;&gt;&#39;);
// AssertionError [ERR_ASSERTION]: 1 &gt; 2

assert.fail(1, 2, &#39;fail&#39;);
// AssertionError [ERR_ASSERTION]: fail

assert.fail(1, 2, &#39;whoops&#39;, &#39;&gt;&#39;);
// AssertionError [ERR_ASSERTION]: whoops

assert.fail(1, 2, new TypeError(&#39;need array&#39;));
// TypeError: need array
</code></pre>
<p>In the last three cases <code>actual</code>, <code>expected</code>, and <code>operator</code> have no
influence on the error message.</p>
<p>Example use of <code>stackStartFunction</code> for truncating the exception&#39;s stacktrace:</p>
<pre><code class="lang-js">function suppressFrame() {
  assert.fail(&#39;a&#39;, &#39;b&#39;, undefined, &#39;!==&#39;, suppressFrame);
}
suppressFrame();
// AssertionError [ERR_ASSERTION]: &#39;a&#39; !== &#39;b&#39;
//     at repl:1:1
//     at ContextifyScript.Script.runInThisContext (vm.js:44:33)
//     ...
</code></pre>
<h2>ifError - v10.0.0</h2><p>Throws <code>value</code> if <code>value</code> is not <code>undefined</code> or <code>null</code>. This is useful when
testing the <code>error</code> argument in callbacks. The stack trace contains all frames
from the error passed to <code>ifError()</code> including the potential new frames for
<code>ifError()</code> itself. See below for an example.</p>
<pre><code class="lang-js">const assert = require(&#39;assert&#39;).strict;

assert.ifError(null);
// OK
assert.ifError(0);
// AssertionError [ERR_ASSERTION]: ifError got unwanted exception: 0
assert.ifError(&#39;error&#39;);
// AssertionError [ERR_ASSERTION]: ifError got unwanted exception: &#39;error&#39;
assert.ifError(new Error());
// AssertionError [ERR_ASSERTION]: ifError got unwanted exception: Error

// Create some random error frames.
let err;
(function errorFrame() {
  err = new Error(&#39;test error&#39;);
})();

(function ifErrorFrame() {
  assert.ifError(err);
})();
// AssertionError [ERR_ASSERTION]: ifError got unwanted exception: test error
//     at ifErrorFrame
//     at errorFrame
</code></pre>
<h2>notStrictEqual - v10.0.0</h2><p>Tests strict inequality between the <code>actual</code> and <code>expected</code> parameters as
determined by the <a href="https://tc39.github.io/ecma262/#sec-samevalue">SameValue Comparison</a>.</p>
<pre><code class="lang-js">const assert = require(&#39;assert&#39;).strict;

assert.notStrictEqual(1, 2);
// OK

assert.notStrictEqual(1, 1);
// AssertionError [ERR_ASSERTION]: Identical input passed to notStrictEqual: 1

assert.notStrictEqual(1, &#39;1&#39;);
// OK
</code></pre>
<p>If the values are strictly equal, an <code>AssertionError</code> is thrown with a <code>message</code>
property set equal to the value of the <code>message</code> parameter. If the <code>message</code>
parameter is undefined, a default error message is assigned. If the <code>message</code>
parameter is an instance of an <a href="errors.html#errors_class_error"><code>Error</code></a> then it will be thrown instead of the
<code>AssertionError</code>.</p>
<h2>ok - v10.0.0</h2><p>Tests if <code>value</code> is truthy. It is equivalent to
<code>assert.equal(!!value, true, message)</code>.</p>
<p>If <code>value</code> is not truthy, an <code>AssertionError</code> is thrown with a <code>message</code>
property set equal to the value of the <code>message</code> parameter. If the <code>message</code>
parameter is <code>undefined</code>, a default error message is assigned. If the <code>message</code>
parameter is an instance of an <a href="errors.html#errors_class_error"><code>Error</code></a> then it will be thrown instead of the
<code>AssertionError</code>.
If no arguments are passed in at all <code>message</code> will be set to the string:
<code>&#39;No value argument passed to `assert.ok()`&#39;</code>.</p>
<p>Be aware that in the <code>repl</code> the error message will be different to the one
thrown in a file! See below for further details.</p>
<pre><code class="lang-js">const assert = require(&#39;assert&#39;).strict;

assert.ok(true);
// OK
assert.ok(1);
// OK

assert.ok();
// AssertionError: No value argument passed to `assert.ok()`

assert.ok(false, &#39;it\&#39;s false&#39;);
// AssertionError: it&#39;s false

// In the repl:
assert.ok(typeof 123 === &#39;string&#39;);
// AssertionError: false == true

// In a file (e.g. test.js):
assert.ok(typeof 123 === &#39;string&#39;);
// AssertionError: The expression evaluated to a falsy value:
//
//   assert.ok(typeof 123 === &#39;string&#39;)

assert.ok(false);
// AssertionError: The expression evaluated to a falsy value:
//
//   assert.ok(false)

assert.ok(0);
// AssertionError: The expression evaluated to a falsy value:
//
//   assert.ok(0)

// Using `assert()` works the same:
assert(0);
// AssertionError: The expression evaluated to a falsy value:
//
//   assert(0)
</code></pre>
<h2>rejects - v10.0.0</h2><p>Awaits the <code>block</code> promise or, if <code>block</code> is a function, immediately calls the
function and awaits the returned promise to complete. It will then check that
the promise is rejected.</p>
<p>If <code>block</code> is a function and it throws an error synchronously,
<code>assert.rejects()</code> will return a rejected <code>Promise</code> with that error. If the
function does not return a promise, <code>assert.rejects()</code> will return a rejected
<code>Promise</code> with an <a href="errors.html#errors_err_invalid_return_value"><code>ERR_INVALID_RETURN_VALUE</code></a> error. In both cases the error
handler is skipped.</p>
<p>Besides the async nature to await the completion behaves identically to
<a href="#assert_assert_throws_block_error_message"><code>assert.throws()</code></a>.</p>
<p>If specified, <code>error</code> can be a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes"><code>Class</code></a>, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions"><code>RegExp</code></a>, a validation function,
an object where each property will be tested for, or an instance of error where
each property will be tested for including the non-enumerable <code>message</code> and
<code>name</code> properties.</p>
<p>If specified, <code>message</code> will be the message provided by the <code>AssertionError</code> if
the block fails to reject.</p>
<pre><code class="lang-js">(async () =&gt; {
  await assert.rejects(
    async () =&gt; {
      throw new TypeError(&#39;Wrong value&#39;);
    },
    {
      name: &#39;TypeError&#39;,
      message: &#39;Wrong value&#39;
    }
  );
})();
</code></pre>
<pre><code class="lang-js">assert.rejects(
  Promise.reject(new Error(&#39;Wrong value&#39;)),
  Error
).then(() =&gt; {
  // ...
});
</code></pre>
<p>Note that <code>error</code> cannot be a string. If a string is provided as the second
argument, then <code>error</code> is assumed to be omitted and the string will be used for
<code>message</code> instead. This can lead to easy-to-miss mistakes. Please read the
example in <a href="#assert_assert_throws_block_error_message"><code>assert.throws()</code></a> carefully if using a string as the second
argument gets considered.</p>
<h2>strictEqual - v10.0.0</h2><p>Tests strict equality between the <code>actual</code> and <code>expected</code> parameters as
determined by the <a href="https://tc39.github.io/ecma262/#sec-samevalue">SameValue Comparison</a>.</p>
<pre><code class="lang-js">const assert = require(&#39;assert&#39;).strict;

assert.strictEqual(1, 2);
// AssertionError [ERR_ASSERTION]: Input A expected to strictly equal input B:
// + expected - actual
// - 1
// + 2

assert.strictEqual(1, 1);
// OK

assert.strictEqual(1, &#39;1&#39;);
// AssertionError [ERR_ASSERTION]: Input A expected to strictly equal input B:
// + expected - actual
// - 1
// + &#39;1&#39;
</code></pre>
<p>If the values are not strictly equal, an <code>AssertionError</code> is thrown with a
<code>message</code> property set equal to the value of the <code>message</code> parameter. If the
<code>message</code> parameter is undefined, a default error message is assigned. If the
<code>message</code> parameter is an instance of an <a href="errors.html#errors_class_error"><code>Error</code></a> then it will be thrown
instead of the <code>AssertionError</code>.</p>
<h2>throws - v10.2.0</h2><p>Expects the function <code>block</code> to throw an error.</p>
<p>If specified, <code>error</code> can be a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes"><code>Class</code></a>, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions"><code>RegExp</code></a>, a validation function,
a validation object where each property will be tested for strict deep equality,
or an instance of error where each property will be tested for strict deep
equality including the non-enumerable <code>message</code> and <code>name</code> properties. When
using an object, it is also possible to use a regular expression, when
validating against a string property. See below for examples.</p>
<p>If specified, <code>message</code> will be the message provided by the <code>AssertionError</code> if
the block fails to throw.</p>
<p>Custom validation object / error instance:</p>
<pre><code class="lang-js">const err = new TypeError(&#39;Wrong value&#39;);
err.code = 404;
err.foo = &#39;bar&#39;;
err.info = {
  nested: true,
  baz: &#39;text&#39;
};
err.reg = /abc/i;

assert.throws(
  () =&gt; {
    throw err;
  },
  {
    name: &#39;TypeError&#39;,
    message: &#39;Wrong value&#39;,
    info: {
      nested: true,
      baz: &#39;text&#39;
    }
    // Note that only properties on the validation object will be tested for.
    // Using nested objects requires all properties to be present. Otherwise
    // the validation is going to fail.
  }
);

// Using regular expressions to validate error properties:
assert.throws(
  () =&gt; {
    throw err;
  },
  {
    // The `name` and `message` properties are strings and using regular
    // expressions on those will match against the string. If they fail, an
    // error is thrown.
    name: /^TypeError$/,
    message: /Wrong/,
    foo: &#39;bar&#39;,
    info: {
      nested: true,
      // It is not possible to use regular expressions for nested properties!
      baz: &#39;text&#39;
    },
    // The `reg` property contains a regular expression and only if the
    // validation object contains an identical regular expression, it is going
    // to pass.
    reg: /abc/i
  }
);

// Fails due to the different `message` and `name` properties:
assert.throws(
  () =&gt; {
    const otherErr = new Error(&#39;Not found&#39;);
    otherErr.code = 404;
    throw otherErr;
  },
  err // This tests for `message`, `name` and `code`.
);
</code></pre>
<p>Validate instanceof using constructor:</p>
<pre><code class="lang-js">assert.throws(
  () =&gt; {
    throw new Error(&#39;Wrong value&#39;);
  },
  Error
);
</code></pre>
<p>Validate error message using <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions"><code>RegExp</code></a>:</p>
<p>Using a regular expression runs <code>.toString</code> on the error object, and will
therefore also include the error name.</p>
<pre><code class="lang-js">assert.throws(
  () =&gt; {
    throw new Error(&#39;Wrong value&#39;);
  },
  /^Error: Wrong value$/
);
</code></pre>
<p>Custom error validation:</p>
<pre><code class="lang-js">assert.throws(
  () =&gt; {
    throw new Error(&#39;Wrong value&#39;);
  },
  function(err) {
    if ((err instanceof Error) &amp;&amp; /value/.test(err)) {
      return true;
    }
  },
  &#39;unexpected error&#39;
);
</code></pre>
<p>Note that <code>error</code> cannot be a string. If a string is provided as the second
argument, then <code>error</code> is assumed to be omitted and the string will be used for
<code>message</code> instead. This can lead to easy-to-miss mistakes. Using the same
message as the thrown error message is going to result in an
<code>ERR_AMBIGUOUS_ARGUMENT</code> error. Please read the example below carefully if using
a string as the second argument gets considered:</p>
<!-- eslint-disable no-restricted-syntax -->
<pre><code class="lang-js">function throwingFirst() {
  throw new Error(&#39;First&#39;);
}
function throwingSecond() {
  throw new Error(&#39;Second&#39;);
}
function notThrowing() {}

// The second argument is a string and the input function threw an Error.
// The first case will not throw as it does not match for the error message
// thrown by the input function!
assert.throws(throwingFirst, &#39;Second&#39;);
// In the next example the message has no benefit over the message from the
// error and since it is not clear if the user intended to actually match
// against the error message, Node.js thrown an `ERR_AMBIGUOUS_ARGUMENT` error.
assert.throws(throwingSecond, &#39;Second&#39;);
// Throws an error:
// TypeError [ERR_AMBIGUOUS_ARGUMENT]

// The string is only used (as message) in case the function does not throw:
assert.throws(notThrowing, &#39;Second&#39;);
// AssertionError [ERR_ASSERTION]: Missing expected exception: Second

// If it was intended to match for the error message do this instead:
assert.throws(throwingSecond, /Second$/);
// Does not throw because the error messages match.
assert.throws(throwingFirst, /Second$/);
// Throws an error:
// Error: First
//     at throwingFirst (repl:2:9)
</code></pre>
<p>Due to the confusing notation, it is recommended not to use a string as the
second argument. This might lead to difficult-to-spot errors.</p>
<!-- [end-include:assert.md] -->
<!-- [start-include:async_hooks.md] -->
<h2>runInAsyncScope - v9.6.0</h2><p>Call the provided function with the provided arguments in the execution context
of the async resource. This will establish the context, trigger the AsyncHooks
before callbacks, call the function, trigger the AsyncHooks after callbacks, and
then restore the original execution context.</p>
<h2>emitBefore - v9.6.0</h2><p>Call all <code>before</code> callbacks to notify that a new asynchronous execution context
is being entered. If nested calls to <code>emitBefore()</code> are made, the stack of
<code>asyncId</code>s will be tracked and properly unwound.</p>
<p><code>before</code> and <code>after</code> calls must be unwound in the same order that they
are called. Otherwise, an unrecoverable exception will occur and the process
will abort. For this reason, the <code>emitBefore</code> and <code>emitAfter</code> APIs are
considered deprecated. Please use <code>runInAsyncScope</code>, as it provides a much safer
alternative.</p>
<h2>emitAfter - v9.6.0</h2><p>Call all <code>after</code> callbacks. If nested calls to <code>emitBefore()</code> were made, then
make sure the stack is unwound properly. Otherwise an error will be thrown.</p>
<p>If the user&#39;s callback throws an exception, <code>emitAfter()</code> will automatically be
called for all <code>asyncId</code>s on the stack if the error is handled by a domain or
<code>&#39;uncaughtException&#39;</code> handler.</p>
<p><code>before</code> and <code>after</code> calls must be unwound in the same order that they
are called. Otherwise, an unrecoverable exception will occur and the process
will abort. For this reason, the <code>emitBefore</code> and <code>emitAfter</code> APIs are
considered deprecated. Please use <code>runInAsyncScope</code>, as it provides a much safer
alternative.</p>
<h2>fill - v10.0.0</h2><p>Fills <code>buf</code> with the specified <code>value</code>. If the <code>offset</code> and <code>end</code> are not given,
the entire <code>buf</code> will be filled:</p>
<pre><code class="lang-js">// Fill a `Buffer` with the ASCII character &#39;h&#39;.

const b = Buffer.allocUnsafe(50).fill(&#39;h&#39;);

console.log(b.toString());
// Prints: hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh
</code></pre>
<p><code>value</code> is coerced to a <code>uint32</code> value if it is not a string or integer.</p>
<p>If the final write of a <code>fill()</code> operation falls on a multi-byte character,
then only the bytes of that character that fit into <code>buf</code> are written:</p>
<pre><code class="lang-js">// Fill a `Buffer` with a two-byte character.

console.log(Buffer.allocUnsafe(3).fill(&#39;\u0222&#39;));
// Prints: &lt;Buffer c8 a2 c8&gt;
</code></pre>
<p>If <code>value</code> contains invalid characters, it is truncated; if no valid
fill data remains, an exception is thrown:</p>
<pre><code class="lang-js">const buf = Buffer.allocUnsafe(5);

console.log(buf.fill(&#39;a&#39;));
// Prints: &lt;Buffer 61 61 61 61 61&gt;
console.log(buf.fill(&#39;aazz&#39;, &#39;hex&#39;));
// Prints: &lt;Buffer aa aa aa aa aa&gt;
console.log(buf.fill(&#39;zz&#39;, &#39;hex&#39;));
// Throws an exception.
</code></pre>
<h2>readDoubleBE - v10.0.0</h2><p>Reads a 64-bit double from <code>buf</code> at the specified <code>offset</code> with specified
endian format (<code>readDoubleBE()</code> returns big endian, <code>readDoubleLE()</code> returns
little endian).</p>
<pre><code class="lang-js">const buf = Buffer.from([1, 2, 3, 4, 5, 6, 7, 8]);

console.log(buf.readDoubleBE(0));
// Prints: 8.20788039913184e-304
console.log(buf.readDoubleLE(0));
// Prints: 5.447603722011605e-270
console.log(buf.readDoubleLE(1));
// Throws ERR_OUT_OF_RANGE
</code></pre>
<h2>readDoubleLE - v10.0.0</h2><p>Reads a 64-bit double from <code>buf</code> at the specified <code>offset</code> with specified
endian format (<code>readDoubleBE()</code> returns big endian, <code>readDoubleLE()</code> returns
little endian).</p>
<pre><code class="lang-js">const buf = Buffer.from([1, 2, 3, 4, 5, 6, 7, 8]);

console.log(buf.readDoubleBE(0));
// Prints: 8.20788039913184e-304
console.log(buf.readDoubleLE(0));
// Prints: 5.447603722011605e-270
console.log(buf.readDoubleLE(1));
// Throws ERR_OUT_OF_RANGE
</code></pre>
<h2>readFloatBE - v10.0.0</h2><p>Reads a 32-bit float from <code>buf</code> at the specified <code>offset</code> with specified
endian format (<code>readFloatBE()</code> returns big endian, <code>readFloatLE()</code> returns
little endian).</p>
<pre><code class="lang-js">const buf = Buffer.from([1, 2, 3, 4]);

console.log(buf.readFloatBE(0));
// Prints: 2.387939260590663e-38
console.log(buf.readFloatLE(0));
// Prints: 1.539989614439558e-36
console.log(buf.readFloatLE(1));
// Throws ERR_OUT_OF_RANGE
</code></pre>
<h2>readFloatLE - v10.0.0</h2><p>Reads a 32-bit float from <code>buf</code> at the specified <code>offset</code> with specified
endian format (<code>readFloatBE()</code> returns big endian, <code>readFloatLE()</code> returns
little endian).</p>
<pre><code class="lang-js">const buf = Buffer.from([1, 2, 3, 4]);

console.log(buf.readFloatBE(0));
// Prints: 2.387939260590663e-38
console.log(buf.readFloatLE(0));
// Prints: 1.539989614439558e-36
console.log(buf.readFloatLE(1));
// Throws ERR_OUT_OF_RANGE
</code></pre>
<h2>readInt8 - v10.0.0</h2><p>Reads a signed 8-bit integer from <code>buf</code> at the specified <code>offset</code>.</p>
<p>Integers read from a <code>Buffer</code> are interpreted as two&#39;s complement signed values.</p>
<pre><code class="lang-js">const buf = Buffer.from([-1, 5]);

console.log(buf.readInt8(0));
// Prints: -1
console.log(buf.readInt8(1));
// Prints: 5
console.log(buf.readInt8(2));
// Throws ERR_OUT_OF_RANGE
</code></pre>
<h2>readInt16BE - v10.0.0</h2><p>Reads a signed 16-bit integer from <code>buf</code> at the specified <code>offset</code> with
the specified endian format (<code>readInt16BE()</code> returns big endian,
<code>readInt16LE()</code> returns little endian).</p>
<p>Integers read from a <code>Buffer</code> are interpreted as two&#39;s complement signed values.</p>
<pre><code class="lang-js">const buf = Buffer.from([0, 5]);

console.log(buf.readInt16BE(0));
// Prints: 5
console.log(buf.readInt16LE(0));
// Prints: 1280
console.log(buf.readInt16LE(1));
// Throws ERR_OUT_OF_RANGE
</code></pre>
<h2>readInt16LE - v10.0.0</h2><p>Reads a signed 16-bit integer from <code>buf</code> at the specified <code>offset</code> with
the specified endian format (<code>readInt16BE()</code> returns big endian,
<code>readInt16LE()</code> returns little endian).</p>
<p>Integers read from a <code>Buffer</code> are interpreted as two&#39;s complement signed values.</p>
<pre><code class="lang-js">const buf = Buffer.from([0, 5]);

console.log(buf.readInt16BE(0));
// Prints: 5
console.log(buf.readInt16LE(0));
// Prints: 1280
console.log(buf.readInt16LE(1));
// Throws ERR_OUT_OF_RANGE
</code></pre>
<h2>readInt32BE - v10.0.0</h2><p>Reads a signed 32-bit integer from <code>buf</code> at the specified <code>offset</code> with
the specified endian format (<code>readInt32BE()</code> returns big endian,
<code>readInt32LE()</code> returns little endian).</p>
<p>Integers read from a <code>Buffer</code> are interpreted as two&#39;s complement signed values.</p>
<pre><code class="lang-js">const buf = Buffer.from([0, 0, 0, 5]);

console.log(buf.readInt32BE(0));
// Prints: 5
console.log(buf.readInt32LE(0));
// Prints: 83886080
console.log(buf.readInt32LE(1));
// Throws ERR_OUT_OF_RANGE
</code></pre>
<h2>readInt32LE - v10.0.0</h2><p>Reads a signed 32-bit integer from <code>buf</code> at the specified <code>offset</code> with
the specified endian format (<code>readInt32BE()</code> returns big endian,
<code>readInt32LE()</code> returns little endian).</p>
<p>Integers read from a <code>Buffer</code> are interpreted as two&#39;s complement signed values.</p>
<pre><code class="lang-js">const buf = Buffer.from([0, 0, 0, 5]);

console.log(buf.readInt32BE(0));
// Prints: 5
console.log(buf.readInt32LE(0));
// Prints: 83886080
console.log(buf.readInt32LE(1));
// Throws ERR_OUT_OF_RANGE
</code></pre>
<h2>readIntBE - v10.0.0</h2><p>Reads <code>byteLength</code> number of bytes from <code>buf</code> at the specified <code>offset</code>
and interprets the result as a two&#39;s complement signed value. Supports up to 48
bits of accuracy.</p>
<pre><code class="lang-js">const buf = Buffer.from([0x12, 0x34, 0x56, 0x78, 0x90, 0xab]);

console.log(buf.readIntLE(0, 6).toString(16));
// Prints: -546f87a9cbee
console.log(buf.readIntBE(0, 6).toString(16));
// Prints: 1234567890ab
console.log(buf.readIntBE(1, 6).toString(16));
// Throws ERR_INDEX_OUT_OF_RANGE
console.log(buf.readIntBE(1, 0).toString(16));
// Throws ERR_OUT_OF_RANGE
</code></pre>
<h2>readIntLE - v10.0.0</h2><p>Reads <code>byteLength</code> number of bytes from <code>buf</code> at the specified <code>offset</code>
and interprets the result as a two&#39;s complement signed value. Supports up to 48
bits of accuracy.</p>
<pre><code class="lang-js">const buf = Buffer.from([0x12, 0x34, 0x56, 0x78, 0x90, 0xab]);

console.log(buf.readIntLE(0, 6).toString(16));
// Prints: -546f87a9cbee
console.log(buf.readIntBE(0, 6).toString(16));
// Prints: 1234567890ab
console.log(buf.readIntBE(1, 6).toString(16));
// Throws ERR_INDEX_OUT_OF_RANGE
console.log(buf.readIntBE(1, 0).toString(16));
// Throws ERR_OUT_OF_RANGE
</code></pre>
<h2>readUInt8 - v10.0.0</h2><p>Reads an unsigned 8-bit integer from <code>buf</code> at the specified <code>offset</code>.</p>
<pre><code class="lang-js">const buf = Buffer.from([1, -2]);

console.log(buf.readUInt8(0));
// Prints: 1
console.log(buf.readUInt8(1));
// Prints: 254
console.log(buf.readUInt8(2));
// Throws ERR_OUT_OF_RANGE
</code></pre>
<h2>readUInt16BE - v10.0.0</h2><p>Reads an unsigned 16-bit integer from <code>buf</code> at the specified <code>offset</code> with
specified endian format (<code>readUInt16BE()</code> returns big endian, <code>readUInt16LE()</code>
returns little endian).</p>
<pre><code class="lang-js">const buf = Buffer.from([0x12, 0x34, 0x56]);

console.log(buf.readUInt16BE(0).toString(16));
// Prints: 1234
console.log(buf.readUInt16LE(0).toString(16));
// Prints: 3412
console.log(buf.readUInt16BE(1).toString(16));
// Prints: 3456
console.log(buf.readUInt16LE(1).toString(16));
// Prints: 5634
console.log(buf.readUInt16LE(2).toString(16));
// Throws ERR_OUT_OF_RANGE
</code></pre>
<h2>readUInt16LE - v10.0.0</h2><p>Reads an unsigned 16-bit integer from <code>buf</code> at the specified <code>offset</code> with
specified endian format (<code>readUInt16BE()</code> returns big endian, <code>readUInt16LE()</code>
returns little endian).</p>
<pre><code class="lang-js">const buf = Buffer.from([0x12, 0x34, 0x56]);

console.log(buf.readUInt16BE(0).toString(16));
// Prints: 1234
console.log(buf.readUInt16LE(0).toString(16));
// Prints: 3412
console.log(buf.readUInt16BE(1).toString(16));
// Prints: 3456
console.log(buf.readUInt16LE(1).toString(16));
// Prints: 5634
console.log(buf.readUInt16LE(2).toString(16));
// Throws ERR_OUT_OF_RANGE
</code></pre>
<h2>readUInt32BE - v10.0.0</h2><p>Reads an unsigned 32-bit integer from <code>buf</code> at the specified <code>offset</code> with
specified endian format (<code>readUInt32BE()</code> returns big endian,
<code>readUInt32LE()</code> returns little endian).</p>
<pre><code class="lang-js">const buf = Buffer.from([0x12, 0x34, 0x56, 0x78]);

console.log(buf.readUInt32BE(0).toString(16));
// Prints: 12345678
console.log(buf.readUInt32LE(0).toString(16));
// Prints: 78563412
console.log(buf.readUInt32LE(1).toString(16));
// Throws ERR_OUT_OF_RANGE
</code></pre>
<h2>readUInt32LE - v10.0.0</h2><p>Reads an unsigned 32-bit integer from <code>buf</code> at the specified <code>offset</code> with
specified endian format (<code>readUInt32BE()</code> returns big endian,
<code>readUInt32LE()</code> returns little endian).</p>
<pre><code class="lang-js">const buf = Buffer.from([0x12, 0x34, 0x56, 0x78]);

console.log(buf.readUInt32BE(0).toString(16));
// Prints: 12345678
console.log(buf.readUInt32LE(0).toString(16));
// Prints: 78563412
console.log(buf.readUInt32LE(1).toString(16));
// Throws ERR_OUT_OF_RANGE
</code></pre>
<h2>readUIntBE - v10.0.0</h2><p>Reads <code>byteLength</code> number of bytes from <code>buf</code> at the specified <code>offset</code>
and interprets the result as an unsigned integer. Supports up to 48
bits of accuracy.</p>
<pre><code class="lang-js">const buf = Buffer.from([0x12, 0x34, 0x56, 0x78, 0x90, 0xab]);

console.log(buf.readUIntBE(0, 6).toString(16));
// Prints: 1234567890ab
console.log(buf.readUIntLE(0, 6).toString(16));
// Prints: ab9078563412
console.log(buf.readUIntBE(1, 6).toString(16));
// Throws ERR_OUT_OF_RANGE
</code></pre>
<h2>readUIntLE - v10.0.0</h2><p>Reads <code>byteLength</code> number of bytes from <code>buf</code> at the specified <code>offset</code>
and interprets the result as an unsigned integer. Supports up to 48
bits of accuracy.</p>
<pre><code class="lang-js">const buf = Buffer.from([0x12, 0x34, 0x56, 0x78, 0x90, 0xab]);

console.log(buf.readUIntBE(0, 6).toString(16));
// Prints: 1234567890ab
console.log(buf.readUIntLE(0, 6).toString(16));
// Prints: ab9078563412
console.log(buf.readUIntBE(1, 6).toString(16));
// Throws ERR_OUT_OF_RANGE
</code></pre>
<h2>writeDoubleBE - v10.0.0</h2><p>Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code> with specified endian
format (<code>writeDoubleBE()</code> writes big endian, <code>writeDoubleLE()</code> writes little
endian). <code>value</code> <em>should</em> be a valid 64-bit double. Behavior is undefined when
<code>value</code> is anything other than a 64-bit double.</p>
<pre><code class="lang-js">const buf = Buffer.allocUnsafe(8);

buf.writeDoubleBE(0xdeadbeefcafebabe, 0);

console.log(buf);
// Prints: &lt;Buffer 43 eb d5 b7 dd f9 5f d7&gt;

buf.writeDoubleLE(0xdeadbeefcafebabe, 0);

console.log(buf);
// Prints: &lt;Buffer d7 5f f9 dd b7 d5 eb 43&gt;
</code></pre>
<h2>writeDoubleLE - v10.0.0</h2><p>Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code> with specified endian
format (<code>writeDoubleBE()</code> writes big endian, <code>writeDoubleLE()</code> writes little
endian). <code>value</code> <em>should</em> be a valid 64-bit double. Behavior is undefined when
<code>value</code> is anything other than a 64-bit double.</p>
<pre><code class="lang-js">const buf = Buffer.allocUnsafe(8);

buf.writeDoubleBE(0xdeadbeefcafebabe, 0);

console.log(buf);
// Prints: &lt;Buffer 43 eb d5 b7 dd f9 5f d7&gt;

buf.writeDoubleLE(0xdeadbeefcafebabe, 0);

console.log(buf);
// Prints: &lt;Buffer d7 5f f9 dd b7 d5 eb 43&gt;
</code></pre>
<h2>writeFloatBE - v10.0.0</h2><p>Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code> with specified endian
format (<code>writeFloatBE()</code> writes big endian, <code>writeFloatLE()</code> writes little
endian). <code>value</code> <em>should</em> be a valid 32-bit float. Behavior is undefined when
<code>value</code> is anything other than a 32-bit float.</p>
<pre><code class="lang-js">const buf = Buffer.allocUnsafe(4);

buf.writeFloatBE(0xcafebabe, 0);

console.log(buf);
// Prints: &lt;Buffer 4f 4a fe bb&gt;

buf.writeFloatLE(0xcafebabe, 0);

console.log(buf);
// Prints: &lt;Buffer bb fe 4a 4f&gt;
</code></pre>
<h2>writeFloatLE - v10.0.0</h2><p>Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code> with specified endian
format (<code>writeFloatBE()</code> writes big endian, <code>writeFloatLE()</code> writes little
endian). <code>value</code> <em>should</em> be a valid 32-bit float. Behavior is undefined when
<code>value</code> is anything other than a 32-bit float.</p>
<pre><code class="lang-js">const buf = Buffer.allocUnsafe(4);

buf.writeFloatBE(0xcafebabe, 0);

console.log(buf);
// Prints: &lt;Buffer 4f 4a fe bb&gt;

buf.writeFloatLE(0xcafebabe, 0);

console.log(buf);
// Prints: &lt;Buffer bb fe 4a 4f&gt;
</code></pre>
<h2>writeInt8 - v10.0.0</h2><p>Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code>. <code>value</code> <em>should</em> be a valid
signed 8-bit integer. Behavior is undefined when <code>value</code> is anything other than
a signed 8-bit integer.</p>
<p><code>value</code> is interpreted and written as a two&#39;s complement signed integer.</p>
<pre><code class="lang-js">const buf = Buffer.allocUnsafe(2);

buf.writeInt8(2, 0);
buf.writeInt8(-2, 1);

console.log(buf);
// Prints: &lt;Buffer 02 fe&gt;
</code></pre>
<h2>writeInt16BE - v10.0.0</h2><p>Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code> with specified endian
format (<code>writeInt16BE()</code> writes big endian, <code>writeInt16LE()</code> writes little
endian). <code>value</code> <em>should</em> be a valid signed 16-bit integer. Behavior is
undefined when <code>value</code> is anything other than a signed 16-bit integer.</p>
<p><code>value</code> is interpreted and written as a two&#39;s complement signed integer.</p>
<pre><code class="lang-js">const buf = Buffer.allocUnsafe(4);

buf.writeInt16BE(0x0102, 0);
buf.writeInt16LE(0x0304, 2);

console.log(buf);
// Prints: &lt;Buffer 01 02 04 03&gt;
</code></pre>
<h2>writeInt16LE - v10.0.0</h2><p>Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code> with specified endian
format (<code>writeInt16BE()</code> writes big endian, <code>writeInt16LE()</code> writes little
endian). <code>value</code> <em>should</em> be a valid signed 16-bit integer. Behavior is
undefined when <code>value</code> is anything other than a signed 16-bit integer.</p>
<p><code>value</code> is interpreted and written as a two&#39;s complement signed integer.</p>
<pre><code class="lang-js">const buf = Buffer.allocUnsafe(4);

buf.writeInt16BE(0x0102, 0);
buf.writeInt16LE(0x0304, 2);

console.log(buf);
// Prints: &lt;Buffer 01 02 04 03&gt;
</code></pre>
<h2>writeInt32BE - v10.0.0</h2><p>Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code> with specified endian
format (<code>writeInt32BE()</code> writes big endian, <code>writeInt32LE()</code> writes little
endian). <code>value</code> <em>should</em> be a valid signed 32-bit integer. Behavior is
undefined when <code>value</code> is anything other than a signed 32-bit integer.</p>
<p><code>value</code> is interpreted and written as a two&#39;s complement signed integer.</p>
<pre><code class="lang-js">const buf = Buffer.allocUnsafe(8);

buf.writeInt32BE(0x01020304, 0);
buf.writeInt32LE(0x05060708, 4);

console.log(buf);
// Prints: &lt;Buffer 01 02 03 04 08 07 06 05&gt;
</code></pre>
<h2>writeInt32LE - v10.0.0</h2><p>Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code> with specified endian
format (<code>writeInt32BE()</code> writes big endian, <code>writeInt32LE()</code> writes little
endian). <code>value</code> <em>should</em> be a valid signed 32-bit integer. Behavior is
undefined when <code>value</code> is anything other than a signed 32-bit integer.</p>
<p><code>value</code> is interpreted and written as a two&#39;s complement signed integer.</p>
<pre><code class="lang-js">const buf = Buffer.allocUnsafe(8);

buf.writeInt32BE(0x01020304, 0);
buf.writeInt32LE(0x05060708, 4);

console.log(buf);
// Prints: &lt;Buffer 01 02 03 04 08 07 06 05&gt;
</code></pre>
<h2>writeIntBE - v10.0.0</h2><p>Writes <code>byteLength</code> bytes of <code>value</code> to <code>buf</code> at the specified <code>offset</code>.
Supports up to 48 bits of accuracy. Behavior is undefined when <code>value</code> is
anything other than a signed integer.</p>
<pre><code class="lang-js">const buf = Buffer.allocUnsafe(6);

buf.writeIntBE(0x1234567890ab, 0, 6);

console.log(buf);
// Prints: &lt;Buffer 12 34 56 78 90 ab&gt;

buf.writeIntLE(0x1234567890ab, 0, 6);

console.log(buf);
// Prints: &lt;Buffer ab 90 78 56 34 12&gt;
</code></pre>
<h2>writeIntLE - v10.0.0</h2><p>Writes <code>byteLength</code> bytes of <code>value</code> to <code>buf</code> at the specified <code>offset</code>.
Supports up to 48 bits of accuracy. Behavior is undefined when <code>value</code> is
anything other than a signed integer.</p>
<pre><code class="lang-js">const buf = Buffer.allocUnsafe(6);

buf.writeIntBE(0x1234567890ab, 0, 6);

console.log(buf);
// Prints: &lt;Buffer 12 34 56 78 90 ab&gt;

buf.writeIntLE(0x1234567890ab, 0, 6);

console.log(buf);
// Prints: &lt;Buffer ab 90 78 56 34 12&gt;
</code></pre>
<h2>writeUInt8 - v10.0.0</h2><p>Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code>. <code>value</code> <em>should</em> be a
valid unsigned 8-bit integer. Behavior is undefined when <code>value</code> is anything
other than an unsigned 8-bit integer.</p>
<pre><code class="lang-js">const buf = Buffer.allocUnsafe(4);

buf.writeUInt8(0x3, 0);
buf.writeUInt8(0x4, 1);
buf.writeUInt8(0x23, 2);
buf.writeUInt8(0x42, 3);

console.log(buf);
// Prints: &lt;Buffer 03 04 23 42&gt;
</code></pre>
<h2>writeUInt16BE - v10.0.0</h2><p>Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code> with specified endian
format (<code>writeUInt16BE()</code> writes big endian, <code>writeUInt16LE()</code> writes little
endian). <code>value</code> should be a valid unsigned 16-bit integer. Behavior is
undefined when <code>value</code> is anything other than an unsigned 16-bit integer.</p>
<pre><code class="lang-js">const buf = Buffer.allocUnsafe(4);

buf.writeUInt16BE(0xdead, 0);
buf.writeUInt16BE(0xbeef, 2);

console.log(buf);
// Prints: &lt;Buffer de ad be ef&gt;

buf.writeUInt16LE(0xdead, 0);
buf.writeUInt16LE(0xbeef, 2);

console.log(buf);
// Prints: &lt;Buffer ad de ef be&gt;
</code></pre>
<h2>writeUInt16LE - v10.0.0</h2><p>Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code> with specified endian
format (<code>writeUInt16BE()</code> writes big endian, <code>writeUInt16LE()</code> writes little
endian). <code>value</code> should be a valid unsigned 16-bit integer. Behavior is
undefined when <code>value</code> is anything other than an unsigned 16-bit integer.</p>
<pre><code class="lang-js">const buf = Buffer.allocUnsafe(4);

buf.writeUInt16BE(0xdead, 0);
buf.writeUInt16BE(0xbeef, 2);

console.log(buf);
// Prints: &lt;Buffer de ad be ef&gt;

buf.writeUInt16LE(0xdead, 0);
buf.writeUInt16LE(0xbeef, 2);

console.log(buf);
// Prints: &lt;Buffer ad de ef be&gt;
</code></pre>
<h2>writeUInt32BE - v10.0.0</h2><p>Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code> with specified endian
format (<code>writeUInt32BE()</code> writes big endian, <code>writeUInt32LE()</code> writes little
endian). <code>value</code> should be a valid unsigned 32-bit integer. Behavior is
undefined when <code>value</code> is anything other than an unsigned 32-bit integer.</p>
<pre><code class="lang-js">const buf = Buffer.allocUnsafe(4);

buf.writeUInt32BE(0xfeedface, 0);

console.log(buf);
// Prints: &lt;Buffer fe ed fa ce&gt;

buf.writeUInt32LE(0xfeedface, 0);

console.log(buf);
// Prints: &lt;Buffer ce fa ed fe&gt;
</code></pre>
<h2>writeUInt32LE - v10.0.0</h2><p>Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code> with specified endian
format (<code>writeUInt32BE()</code> writes big endian, <code>writeUInt32LE()</code> writes little
endian). <code>value</code> should be a valid unsigned 32-bit integer. Behavior is
undefined when <code>value</code> is anything other than an unsigned 32-bit integer.</p>
<pre><code class="lang-js">const buf = Buffer.allocUnsafe(4);

buf.writeUInt32BE(0xfeedface, 0);

console.log(buf);
// Prints: &lt;Buffer fe ed fa ce&gt;

buf.writeUInt32LE(0xfeedface, 0);

console.log(buf);
// Prints: &lt;Buffer ce fa ed fe&gt;
</code></pre>
<h2>writeUIntBE - v10.0.0</h2><p>Writes <code>byteLength</code> bytes of <code>value</code> to <code>buf</code> at the specified <code>offset</code>.
Supports up to 48 bits of accuracy. Behavior is undefined when <code>value</code> is
anything other than an unsigned integer.</p>
<pre><code class="lang-js">const buf = Buffer.allocUnsafe(6);

buf.writeUIntBE(0x1234567890ab, 0, 6);

console.log(buf);
// Prints: &lt;Buffer 12 34 56 78 90 ab&gt;

buf.writeUIntLE(0x1234567890ab, 0, 6);

console.log(buf);
// Prints: &lt;Buffer ab 90 78 56 34 12&gt;
</code></pre>
<h2>writeUIntLE - v10.0.0</h2><p>Writes <code>byteLength</code> bytes of <code>value</code> to <code>buf</code> at the specified <code>offset</code>.
Supports up to 48 bits of accuracy. Behavior is undefined when <code>value</code> is
anything other than an unsigned integer.</p>
<pre><code class="lang-js">const buf = Buffer.allocUnsafe(6);

buf.writeUIntBE(0x1234567890ab, 0, 6);

console.log(buf);
// Prints: &lt;Buffer 12 34 56 78 90 ab&gt;

buf.writeUIntLE(0x1234567890ab, 0, 6);

console.log(buf);
// Prints: &lt;Buffer ab 90 78 56 34 12&gt;
</code></pre>
<h2>assert - v10.0.0</h2><p>A simple assertion test that verifies whether <code>value</code> is truthy. If it is not,
<code>Assertion failed</code> is logged. If provided, the error <code>message</code> is formatted
using <a href="#util_util_format_format_args"><code>util.format()</code></a> by passing along all message arguments. The output is
used as the error message.</p>
<pre><code class="lang-js">console.assert(true, &#39;does nothing&#39;);
// OK
console.assert(false, &#39;Whoops %s work&#39;, &#39;didn\&#39;t&#39;);
// Assertion failed: Whoops didn&#39;t work
</code></pre>
<p>Calling <code>console.assert()</code> with a falsy assertion will only cause the <code>message</code>
to be printed to the console without interrupting execution of subsequent code.</p>
<h2>debug - v9.3.0</h2><p>The <code>console.debug()</code> function is an alias for <a href="console.html#console_console_log_data_args"><code>console.log()</code></a>.</p>
<h2>dirxml - v9.3.0</h2><p>This method calls <code>console.log()</code> passing it the arguments received.
Please note that this method does not produce any XML formatting.</p>
<h2>table - v10.0.0</h2><p>Try to construct a table with the columns of the properties of <code>tabularData</code>
(or use <code>properties</code>) and rows of <code>tabularData</code> and log it. Falls back to just
logging the argument if it can’t be parsed as tabular.</p>
<pre><code class="lang-js">// These can&#39;t be parsed as tabular data
console.table(Symbol());
// Symbol()

console.table(undefined);
// undefined

console.table([{ a: 1, b: &#39;Y&#39; }, { a: &#39;Z&#39;, b: 2 }]);
// ┌─────────┬─────┬─────┐
// │ (index) │  a  │  b  │
// ├─────────┼─────┼─────┤
// │    0    │  1  │ &#39;Y&#39; │
// │    1    │ &#39;Z&#39; │  2  │
// └─────────┴─────┴─────┘

console.table([{ a: 1, b: &#39;Y&#39; }, { a: &#39;Z&#39;, b: 2 }], [&#39;a&#39;]);
// ┌─────────┬─────┐
// │ (index) │  a  │
// ├─────────┼─────┤
// │    0    │  1  │
// │    1    │ &#39;Z&#39; │
// └─────────┴─────┘
</code></pre>
<h2>createCipher - v10.2.0</h2><p>Creates and returns a <code>Cipher</code> object that uses the given <code>algorithm</code> and
<code>password</code>.</p>
<p>The <code>options</code> argument controls stream behavior and is optional except when a
cipher in CCM mode is used (e.g. <code>&#39;aes-128-ccm&#39;</code>). In that case, the
<code>authTagLength</code> option is required and specifies the length of the
authentication tag in bytes, see <a href="#crypto_ccm_mode">CCM mode</a>. In GCM mode, the <code>authTagLength</code>
option is not required but can be used to set the length of the authentication
tag that will be returned by <code>getAuthTag()</code> and defaults to 16 bytes.</p>
<p>The <code>algorithm</code> is dependent on OpenSSL, examples are <code>&#39;aes192&#39;</code>, etc. On
recent OpenSSL releases, <code>openssl list -cipher-algorithms</code>
(<code>openssl list-cipher-algorithms</code> for older versions of OpenSSL) will
display the available cipher algorithms.</p>
<p>The <code>password</code> is used to derive the cipher key and initialization vector (IV).
The value must be either a <code>&#39;latin1&#39;</code> encoded string, a <a href="buffer.html#buffer_class_buffer"><code>Buffer</code></a>, a
<code>TypedArray</code>, or a <code>DataView</code>.</p>
<p>The implementation of <code>crypto.createCipher()</code> derives keys using the OpenSSL
function <a href="https://www.openssl.org/docs/man1.1.0/crypto/EVP_BytesToKey.html"><code>EVP_BytesToKey</code></a> with the digest algorithm set to MD5, one
iteration, and no salt. The lack of salt allows dictionary attacks as the same
password always creates the same key. The low iteration count and
non-cryptographically secure hash algorithm allow passwords to be tested very
rapidly.</p>
<p>In line with OpenSSL&#39;s recommendation to use PBKDF2 instead of
<a href="https://www.openssl.org/docs/man1.1.0/crypto/EVP_BytesToKey.html"><code>EVP_BytesToKey</code></a> it is recommended that developers derive a key and IV on
their own using <a href="crypto.html#crypto_crypto_pbkdf2_password_salt_iterations_keylen_digest_callback"><code>crypto.pbkdf2()</code></a> and to use <a href="crypto.html#crypto_crypto_createcipheriv_algorithm_key_iv_options"><code>crypto.createCipheriv()</code></a>
to create the <code>Cipher</code> object. Users should not use ciphers with counter mode
(e.g. CTR, GCM, or CCM) in <code>crypto.createCipher()</code>. A warning is emitted when
they are used in order to avoid the risk of IV reuse that causes
vulnerabilities. For the case when IV is reused in GCM, see <a href="https://github.com/nonce-disrespect/nonce-disrespect">Nonce-Disrespecting
Adversaries</a> for details.</p>
<h2>createCipheriv - v10.2.0</h2><p>Creates and returns a <code>Cipher</code> object, with the given <code>algorithm</code>, <code>key</code> and
initialization vector (<code>iv</code>).</p>
<p>The <code>options</code> argument controls stream behavior and is optional except when a
cipher in CCM mode is used (e.g. <code>&#39;aes-128-ccm&#39;</code>). In that case, the
<code>authTagLength</code> option is required and specifies the length of the
authentication tag in bytes, see <a href="#crypto_ccm_mode">CCM mode</a>. In GCM mode, the <code>authTagLength</code>
option is not required but can be used to set the length of the authentication
tag that will be returned by <code>getAuthTag()</code> and defaults to 16 bytes.</p>
<p>The <code>algorithm</code> is dependent on OpenSSL, examples are <code>&#39;aes192&#39;</code>, etc. On
recent OpenSSL releases, <code>openssl list -cipher-algorithms</code>
(<code>openssl list-cipher-algorithms</code> for older versions of OpenSSL) will
display the available cipher algorithms.</p>
<p>The <code>key</code> is the raw key used by the <code>algorithm</code> and <code>iv</code> is an
<a href="https://en.wikipedia.org/wiki/Initialization_vector">initialization vector</a>. Both arguments must be <code>&#39;utf8&#39;</code> encoded strings,
<a href="buffer.html#buffer_class_buffer">Buffers</a>, <code>TypedArray</code>, or <code>DataView</code>s. If the cipher does not need
an initialization vector, <code>iv</code> may be <code>null</code>.</p>
<p>Initialization vectors should be unpredictable and unique; ideally, they will be
cryptographically random. They do not have to be secret: IVs are typically just
added to ciphertext messages unencrypted. It may sound contradictory that
something has to be unpredictable and unique, but does not have to be secret;
it is important to remember that an attacker must not be able to predict ahead
of time what a given IV will be.</p>
<h2>createDecipher - v10.0.0</h2><p>Creates and returns a <code>Decipher</code> object that uses the given <code>algorithm</code> and
<code>password</code> (key).</p>
<p>The <code>options</code> argument controls stream behavior and is optional except when a
cipher in CCM mode is used (e.g. <code>&#39;aes-128-ccm&#39;</code>). In that case, the
<code>authTagLength</code> option is required and specifies the length of the
authentication tag in bytes, see <a href="#crypto_ccm_mode">CCM mode</a>.</p>
<p>The implementation of <code>crypto.createDecipher()</code> derives keys using the OpenSSL
function <a href="https://www.openssl.org/docs/man1.1.0/crypto/EVP_BytesToKey.html"><code>EVP_BytesToKey</code></a> with the digest algorithm set to MD5, one
iteration, and no salt. The lack of salt allows dictionary attacks as the same
password always creates the same key. The low iteration count and
non-cryptographically secure hash algorithm allow passwords to be tested very
rapidly.</p>
<p>In line with OpenSSL&#39;s recommendation to use PBKDF2 instead of
<a href="https://www.openssl.org/docs/man1.1.0/crypto/EVP_BytesToKey.html"><code>EVP_BytesToKey</code></a> it is recommended that developers derive a key and IV on
their own using <a href="crypto.html#crypto_crypto_pbkdf2_password_salt_iterations_keylen_digest_callback"><code>crypto.pbkdf2()</code></a> and to use <a href="crypto.html#crypto_crypto_createdecipheriv_algorithm_key_iv_options"><code>crypto.createDecipheriv()</code></a>
to create the <code>Decipher</code> object.</p>
<h2>createDecipheriv - v10.2.0</h2><p>Creates and returns a <code>Decipher</code> object that uses the given <code>algorithm</code>, <code>key</code>
and initialization vector (<code>iv</code>).</p>
<p>The <code>options</code> argument controls stream behavior and is optional except when a
cipher in CCM mode is used (e.g. <code>&#39;aes-128-ccm&#39;</code>). In that case, the
<code>authTagLength</code> option is required and specifies the length of the
authentication tag in bytes, see <a href="#crypto_ccm_mode">CCM mode</a>. In GCM mode, the <code>authTagLength</code>
option is not required but can be used to restrict accepted authentication tags
to those with the specified length.</p>
<p>The <code>algorithm</code> is dependent on OpenSSL, examples are <code>&#39;aes192&#39;</code>, etc. On
recent OpenSSL releases, <code>openssl list -cipher-algorithms</code>
(<code>openssl list-cipher-algorithms</code> for older versions of OpenSSL) will
display the available cipher algorithms.</p>
<p>The <code>key</code> is the raw key used by the <code>algorithm</code> and <code>iv</code> is an
<a href="https://en.wikipedia.org/wiki/Initialization_vector">initialization vector</a>. Both arguments must be <code>&#39;utf8&#39;</code> encoded strings,
<a href="buffer.html#buffer_class_buffer">Buffers</a>, <code>TypedArray</code>, or <code>DataView</code>s. If the cipher does not need
an initialization vector, <code>iv</code> may be <code>null</code>.</p>
<p>Initialization vectors should be unpredictable and unique; ideally, they will be
cryptographically random. They do not have to be secret: IVs are typically just
added to ciphertext messages unencrypted. It may sound contradictory that
something has to be unpredictable and unique, but does not have to be secret;
it is important to remember that an attacker must not be able to predict ahead
of time what a given IV will be.</p>
<h2>getFips - v10.0.0</h2><p>Example:</p>
<pre><code class="lang-js">const hashes = crypto.getHashes();
console.log(hashes); // [&#39;DSA&#39;, &#39;DSA-SHA&#39;, &#39;DSA-SHA1&#39;, ...]
</code></pre>
<h2>setFips - v10.0.0</h2><p>Enables the FIPS compliant crypto provider in a FIPS-enabled Node.js build.
Throws an error if FIPS mode is not available.</p>
<h2>convertKey - v10.0.0</h2><p>Converts the EC Diffie-Hellman public key specified by <code>key</code> and <code>curve</code> to the
format specified by <code>format</code>. The <code>format</code> argument specifies point encoding
and can be <code>&#39;compressed&#39;</code>, <code>&#39;uncompressed&#39;</code> or <code>&#39;hybrid&#39;</code>. The supplied key is
interpreted using the specified <code>inputEncoding</code>, and the returned key is encoded
using the specified <code>outputEncoding</code>. Encodings can be <code>&#39;latin1&#39;</code>, <code>&#39;hex&#39;</code>,
or <code>&#39;base64&#39;</code>.</p>
<p>Use <a href="crypto.html#crypto_crypto_getcurves"><code>crypto.getCurves()</code></a> to obtain a list of available curve names.
On recent OpenSSL releases, <code>openssl ecparam -list_curves</code> will also display
the name and description of each available elliptic curve.</p>
<p>If <code>format</code> is not specified the point will be returned in <code>&#39;uncompressed&#39;</code>
format.</p>
<p>If the <code>inputEncoding</code> is not provided, <code>key</code> is expected to be a <a href="buffer.html#buffer_class_buffer"><code>Buffer</code></a>,
<code>TypedArray</code>, or <code>DataView</code>.</p>
<p>Example (uncompressing a key):</p>
<pre><code class="lang-js">const { ECDH } = require(&#39;crypto&#39;);

const ecdh = ECDH(&#39;secp256k1&#39;);
ecdh.generateKeys();

const compressedKey = ecdh.getPublicKey(&#39;hex&#39;, &#39;compressed&#39;);

const uncompressedKey = ECDH.convertKey(compressedKey,
                                        &#39;secp256k1&#39;,
                                        &#39;hex&#39;,
                                        &#39;hex&#39;,
                                        &#39;uncompressed&#39;);

// the converted key and the uncompressed public key should be the same
console.log(uncompressedKey === ecdh.getPublicKey(&#39;hex&#39;));
</code></pre>
<h2>off - v10.0.0</h2><p>Alias for <a href="#events_emitter_removelistener_eventname_listener"><code>emitter.removeListener()</code></a>.</p>
<h2>rawListeners - v9.4.0</h2><p>Returns a copy of the array of listeners for the event named <code>eventName</code>,
including any wrappers (such as those created by <code>.once()</code>).</p>
<pre><code class="lang-js">const emitter = new EventEmitter();
emitter.once(&#39;log&#39;, () =&gt; console.log(&#39;log once&#39;));

// Returns a new Array with a function `onceWrapper` which has a property
// `listener` which contains the original listener bound above
const listeners = emitter.rawListeners(&#39;log&#39;);
const logFnWrapper = listeners[0];

// logs &quot;log once&quot; to the console and does not unbind the `once` event
logFnWrapper.listener();

// logs &quot;log once&quot; to the console and removes the listener
logFnWrapper();

emitter.on(&#39;log&#39;, () =&gt; console.log(&#39;log persistently&#39;));
// will return a new Array with a single function bound by `.on()` above
const newListeners = emitter.rawListeners(&#39;log&#39;);

// logs &quot;log persistently&quot; twice
newListeners[0]();
emitter.emit(&#39;log&#39;);
</code></pre>
<!-- [end-include:events.md] -->
<!-- [start-include:fs.md] -->
<h2>FileHandle - v10.0.0</h2><p>A <code>FileHandle</code> object is a wrapper for a numeric file descriptor.
Instances of <code>FileHandle</code> are distinct from numeric file descriptors
in that, if the <code>FileHandle</code> is not explicitly closed using the
<code>filehandle.close()</code> method, they will automatically close the file descriptor
and will emit a process warning, thereby helping to prevent memory leaks.</p>
<p>Instances of the <code>FileHandle</code> object are created internally by the
<code>fsPromises.open()</code> method.</p>
<p>Unlike the callback-based API (<code>fs.fstat()</code>, <code>fs.fchown()</code>, <code>fs.fchmod()</code>, and
so on), a numeric file descriptor is not used by the promise-based API. Instead,
the promise-based API uses the <code>FileHandle</code> class in order to help avoid
accidental leaking of unclosed file descriptors after a <code>Promise</code> is resolved or
rejected.</p>
<h2>appendFile - v10.0.0</h2><p>Asynchronously append data to this file, creating the file if it does not yet
exist. <code>data</code> can be a string or a <a href="buffer.html#buffer_class_buffer"><code>Buffer</code></a>. The <code>Promise</code> will be
resolved with no arguments upon success.</p>
<p>If <code>options</code> is a string, then it specifies the encoding.</p>
<p>The <code>FileHandle</code> must have been opened for appending.</p>
<h2>chmod - v10.0.0</h2><p>Modifies the permissions on the file. The <code>Promise</code> is resolved with no
arguments upon success.</p>
<h2>chown - v10.0.0</h2><p>Changes the ownership of the file then resolves the <code>Promise</code> with no arguments
upon success.</p>
<h2>close - v10.0.0</h2><p>Closes the file descriptor.</p>
<pre><code class="lang-js">const fsPromises = require(&#39;fs&#39;).promises;
async function openAndClose() {
  let filehandle;
  try {
    filehandle = await fsPromises.open(&#39;thefile.txt&#39;, &#39;r&#39;);
  } finally {
    if (filehandle !== undefined)
      await filehandle.close();
  }
}
</code></pre>
<h2>datasync - v10.0.0</h2><p>Asynchronous fdatasync(2). The <code>Promise</code> is resolved with no arguments upon
success.</p>
<h2>read - v10.0.0</h2><p>Read data from the file.</p>
<p><code>buffer</code> is the buffer that the data will be written to.</p>
<p><code>offset</code> is the offset in the buffer to start writing at.</p>
<p><code>length</code> is an integer specifying the number of bytes to read.</p>
<p><code>position</code> is an argument specifying where to begin reading from in the file.
If <code>position</code> is <code>null</code>, data will be read from the current file position,
and the file position will be updated.
If <code>position</code> is an integer, the file position will remain unchanged.</p>
<p>Following successful read, the <code>Promise</code> is resolved with an object with a
<code>bytesRead</code> property specifying the number of bytes read, and a <code>buffer</code>
property that is a reference to the passed in <code>buffer</code> argument.</p>
<h2>readFile - v10.0.0</h2><p>Asynchronously reads the entire contents of a file.</p>
<p>The <code>Promise</code> is resolved with the contents of the file. If no encoding is
specified (using <code>options.encoding</code>), the data is returned as a <code>Buffer</code>
object. Otherwise, the data will be a string.</p>
<p>If <code>options</code> is a string, then it specifies the encoding.</p>
<p>When the <code>path</code> is a directory, the behavior of <code>fsPromises.readFile()</code> is
platform-specific. On macOS, Linux, and Windows, the promise will be rejected
with an error. On FreeBSD, a representation of the directory&#39;s contents will be
returned.</p>
<p>The <code>FileHandle</code> has to support reading.</p>
<h2>stat - v10.0.0</h2><p>Retrieves the <a href="#fs_class_fs_stats"><code>fs.Stats</code></a> for the file.</p>
<h2>sync - v10.0.0</h2><p>Asynchronous fsync(2). The <code>Promise</code> is resolved with no arguments upon
success.</p>
<h2>truncate - v10.0.0</h2><p>Truncates the file then resolves the <code>Promise</code> with no arguments upon success.</p>
<p>If the file was larger than <code>len</code> bytes, only the first <code>len</code> bytes will be
retained in the file.</p>
<p>For example, the following program retains only the first four bytes of the
file:</p>
<pre><code class="lang-js">const fs = require(&#39;fs&#39;);
const fsPromises = fs.promises;

console.log(fs.readFileSync(&#39;temp.txt&#39;, &#39;utf8&#39;));
// Prints: Node.js

async function doTruncate() {
  let filehandle = null;
  try {
    filehandle = await fsPromises.open(&#39;temp.txt&#39;, &#39;r+&#39;);
    await filehandle.truncate(4);
  } finally {
    if (filehandle) {
      // close the file if it is opened.
      await filehandle.close();
    }
  }
  console.log(fs.readFileSync(&#39;temp.txt&#39;, &#39;utf8&#39;));  // Prints: Node
}

doTruncate().catch(console.error);
</code></pre>
<p>If the file previously was shorter than <code>len</code> bytes, it is extended, and the
extended part is filled with null bytes (<code>&#39;\0&#39;</code>). For example,</p>
<pre><code class="lang-js">const fs = require(&#39;fs&#39;);
const fsPromises = fs.promises;

console.log(fs.readFileSync(&#39;temp.txt&#39;, &#39;utf8&#39;));
// Prints: Node.js

async function doTruncate() {
  let filehandle = null;
  try {
    filehandle = await fsPromises.open(&#39;temp.txt&#39;, &#39;r+&#39;);
    await filehandle.truncate(10);
  } finally {
    if (filehandle) {
      // close the file if it is opened.
      await filehandle.close();
    }
  }
  console.log(fs.readFileSync(&#39;temp.txt&#39;, &#39;utf8&#39;));  // Prints Node.js\0\0\0
}

doTruncate().catch(console.error);
</code></pre>
<p>The last three bytes are null bytes (<code>&#39;\0&#39;</code>), to compensate the over-truncation.</p>
<h2>utimes - v10.0.0</h2><p>Change the file system timestamps of the object referenced by the <code>FileHandle</code>
then resolves the <code>Promise</code> with no arguments upon success.</p>
<p>This function does not work on AIX versions before 7.1, it will resolve the
<code>Promise</code> with an error using code <code>UV_ENOSYS</code>.</p>
<h2>write - v10.0.0</h2><p>Write <code>buffer</code> to the file.</p>
<p>The <code>Promise</code> is resolved with an object containing a <code>bytesWritten</code> property
identifying the number of bytes written, and a <code>buffer</code> property containing
a reference to the <code>buffer</code> written.</p>
<p><code>offset</code> determines the part of the buffer to be written, and <code>length</code> is
an integer specifying the number of bytes to write.</p>
<p><code>position</code> refers to the offset from the beginning of the file where this data
should be written. If <code>typeof position !== &#39;number&#39;</code>, the data will be written
at the current position. See pwrite(2).</p>
<p>It is unsafe to use <code>filehandle.write()</code> multiple times on the same file
without waiting for the <code>Promise</code> to be resolved (or rejected). For this
scenario, <code>fs.createWriteStream</code> is strongly recommended.</p>
<p>On Linux, positional writes do not work when the file is opened in append mode.
The kernel ignores the position argument and always appends the data to
the end of the file.</p>
<h2>writeFile - v10.0.0</h2><p>Asynchronously writes data to a file, replacing the file if it already exists.
<code>data</code> can be a string or a buffer. The <code>Promise</code> will be resolved with no
arguments upon success.</p>
<p>The <code>encoding</code> option is ignored if <code>data</code> is a buffer.</p>
<p>If <code>options</code> is a string, then it specifies the encoding.</p>
<p>The <code>FileHandle</code> has to support writing.</p>
<p>It is unsafe to use <code>filehandle.writeFile()</code> multiple times on the same file
without waiting for the <code>Promise</code> to be resolved (or rejected).</p>
<h2>access - v10.0.0</h2><p>Tests a user&#39;s permissions for the file or directory specified by <code>path</code>.
The <code>mode</code> argument is an optional integer that specifies the accessibility
checks to be performed. Check <a href="#fs_file_access_constants">File Access Constants</a> for possible values
of <code>mode</code>. It is possible to create a mask consisting of the bitwise OR of
two or more values (e.g. <code>fs.constants.W_OK | fs.constants.R_OK</code>).</p>
<p>If the accessibility check is successful, the <code>Promise</code> is resolved with no
value. If any of the accessibility checks fail, the <code>Promise</code> is rejected
with an <code>Error</code> object. The following example checks if the file
<code>/etc/passwd</code> can be read and written by the current process.</p>
<pre><code class="lang-js">const fs = require(&#39;fs&#39;);
const fsPromises = fs.promises;

fsPromises.access(&#39;/etc/passwd&#39;, fs.constants.R_OK | fs.constants.W_OK)
  .then(() =&gt; console.log(&#39;can access&#39;))
  .catch(() =&gt; console.error(&#39;cannot access&#39;));
</code></pre>
<p>Using <code>fsPromises.access()</code> to check for the accessibility of a file before
calling <code>fsPromises.open()</code> is not recommended. Doing so introduces a race
condition, since other processes may change the file&#39;s state between the two
calls. Instead, user code should open/read/write the file directly and handle
the error raised if the file is not accessible.</p>
<h2>appendFile - v10.0.0</h2><p>Asynchronously append data to a file, creating the file if it does not yet
exist. <code>data</code> can be a string or a <a href="buffer.html#buffer_class_buffer"><code>Buffer</code></a>. The <code>Promise</code> will be
resolved with no arguments upon success.</p>
<p>If <code>options</code> is a string, then it specifies the encoding.</p>
<p>The <code>path</code> may be specified as a <code>FileHandle</code> that has been opened
for appending (using <code>fsPromises.open()</code>).</p>
<h2>chmod - v10.0.0</h2><p>Changes the permissions of a file then resolves the <code>Promise</code> with no
arguments upon succces.</p>
<h2>chown - v10.0.0</h2><p>Changes the ownership of a file then resolves the <code>Promise</code> with no arguments
upon success.</p>
<h2>copyFile - v10.0.0</h2><p>Asynchronously copies <code>src</code> to <code>dest</code>. By default, <code>dest</code> is overwritten if it
already exists. The <code>Promise</code> will be resolved with no arguments upon success.</p>
<p>Node.js makes no guarantees about the atomicity of the copy operation. If an
error occurs after the destination file has been opened for writing, Node.js
will attempt to remove the destination.</p>
<p><code>flags</code> is an optional integer that specifies the behavior
of the copy operation. It is possible to create a mask consisting of the bitwise
OR of two or more values (e.g.
<code>fs.constants.COPYFILE_EXCL | fs.constants.COPYFILE_FICLONE</code>).</p>
<ul>
<li><code>fs.constants.COPYFILE_EXCL</code> - The copy operation will fail if <code>dest</code> already
exists.</li>
<li><code>fs.constants.COPYFILE_FICLONE</code> - The copy operation will attempt to create a
copy-on-write reflink. If the platform does not support copy-on-write, then a
fallback copy mechanism is used.</li>
<li><code>fs.constants.COPYFILE_FICLONE_FORCE</code> - The copy operation will attempt to
create a copy-on-write reflink. If the platform does not support copy-on-write,
then the operation will fail.</li>
</ul>
<p>Example:</p>
<pre><code class="lang-js">const fsPromises = require(&#39;fs&#39;).promises;

// destination.txt will be created or overwritten by default.
fsPromises.copyFile(&#39;source.txt&#39;, &#39;destination.txt&#39;)
  .then(() =&gt; console.log(&#39;source.txt was copied to destination.txt&#39;))
  .catch(() =&gt; console.log(&#39;The file could not be copied&#39;));
</code></pre>
<p>If the third argument is a number, then it specifies <code>flags</code>, as shown in the
following example.</p>
<pre><code class="lang-js">const fs = require(&#39;fs&#39;);
const fsPromises = fs.promises;
const { COPYFILE_EXCL } = fs.constants;

// By using COPYFILE_EXCL, the operation will fail if destination.txt exists.
fsPromises.copyFile(&#39;source.txt&#39;, &#39;destination.txt&#39;, COPYFILE_EXCL)
  .then(() =&gt; console.log(&#39;source.txt was copied to destination.txt&#39;))
  .catch(() =&gt; console.log(&#39;The file could not be copied&#39;));
</code></pre>
<h2>fchmod - v10.0.0</h2><p>Asynchronous fchmod(2). The <code>Promise</code> is resolved with no arguments upon
success.</p>
<h2>fchown - v10.0.0</h2><p>Changes the ownership of the file represented by <code>filehandle</code> then resolves
the <code>Promise</code> with no arguments upon success.</p>
<h2>fdatasync - v10.0.0</h2><p>Asynchronous fdatasync(2). The <code>Promise</code> is resolved with no arguments upon
success.</p>
<h2>fstat - v10.0.0</h2><p>Retrieves the <a href="#fs_class_fs_stats"><code>fs.Stats</code></a> for the given <code>filehandle</code>.</p>
<h2>fsync - v10.0.0</h2><p>Asynchronous fsync(2). The <code>Promise</code> is resolved with no arguments upon
success.</p>
<h2>ftruncate - v10.0.0</h2><p>Truncates the file represented by <code>filehandle</code> then resolves the <code>Promise</code>
with no arguments upon success.</p>
<p>If the file referred to by the <code>FileHandle</code> was larger than <code>len</code> bytes, only
the first <code>len</code> bytes will be retained in the file.</p>
<p>For example, the following program retains only the first four bytes of the
file:</p>
<pre><code class="lang-js">console.log(fs.readFileSync(&#39;temp.txt&#39;, &#39;utf8&#39;));
// Prints: Node.js

async function doTruncate() {
  const fd = await fsPromises.open(&#39;temp.txt&#39;, &#39;r+&#39;);
  await fsPromises.ftruncate(fd, 4);
  console.log(fs.readFileSync(&#39;temp.txt&#39;, &#39;utf8&#39;));  // Prints: Node
}

doTruncate().catch(console.error);
</code></pre>
<p>If the file previously was shorter than <code>len</code> bytes, it is extended, and the
extended part is filled with null bytes (<code>&#39;\0&#39;</code>). For example,</p>
<pre><code class="lang-js">console.log(fs.readFileSync(&#39;temp.txt&#39;, &#39;utf8&#39;));
// Prints: Node.js

async function doTruncate() {
  const fd = await fsPromises.open(&#39;temp.txt&#39;, &#39;r+&#39;);
  await fsPromises.ftruncate(fd, 10);
  console.log(fs.readFileSync(&#39;temp.txt&#39;, &#39;utf8&#39;));  // Prints Node.js\0\0\0
}

doTruncate().catch(console.error);
</code></pre>
<p>The last three bytes are null bytes (<code>&#39;\0&#39;</code>), to compensate the over-truncation.</p>
<h2>futimes - v10.0.0</h2><p>Change the file system timestamps of the object referenced by the supplied
<code>FileHandle</code> then resolves the <code>Promise</code> with no arguments upon success.</p>
<p>This function does not work on AIX versions before 7.1, it will resolve the
<code>Promise</code> with an error using code <code>UV_ENOSYS</code>.</p>
<h2>lchmod - v10.0.0</h2><p>Changes the permissions on a symbolic link then resolves the <code>Promise</code> with
no arguments upon success. This method is only implemented on macOS.</p>
<h2>lchown - v10.0.0</h2><p>Changes the ownership on a symbolic link then resolves the <code>Promise</code> with
no arguments upon success. This method is only implemented on macOS.</p>
<h2>link - v10.0.0</h2><p>Asynchronous link(2). The <code>Promise</code> is resolved with no arguments upon success.</p>
<h2>lstat - v10.0.0</h2><p>Asynchronous lstat(2). The <code>Promise</code> is resolved with the <a href="#fs_class_fs_stats"><code>fs.Stats</code></a> object
for the given symbolic link <code>path</code>.</p>
<h2>mkdir - v10.0.0</h2><p>Asynchronously creates a directory then resolves the <code>Promise</code> with no
arguments upon success.</p>
<h2>mkdtemp - v10.0.0</h2><p>Creates a unique temporary directory and resolves the <code>Promise</code> with the created
folder path. A unique directory name is generated by appending six random
characters to the end of the provided <code>prefix</code>.</p>
<p>The optional <code>options</code> argument can be a string specifying an encoding, or an
object with an <code>encoding</code> property specifying the character encoding to use.</p>
<pre><code class="lang-js">fsPromises.mkdtemp(path.join(os.tmpdir(), &#39;foo-&#39;))
  .catch(console.error);
</code></pre>
<p>The <code>fsPromises.mkdtemp()</code> method will append the six randomly selected
characters directly to the <code>prefix</code> string. For instance, given a directory
<code>/tmp</code>, if the intention is to create a temporary directory <em>within</em> <code>/tmp</code>, the
<code>prefix</code> must end with a trailing platform-specific path separator
(<code>require(&#39;path&#39;).sep</code>).</p>
<h2>open - v10.0.0</h2><p>Asynchronous file open that returns a <code>Promise</code> that, when resolved, yields a
<code>FileHandle</code> object. See open(2).</p>
<p><code>mode</code> sets the file mode (permission and sticky bits), but only if the file was
created.</p>
<p>Some characters (<code>&lt; &gt; : &quot; / \ | ? *</code>) are reserved under Windows as documented
by <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa365247(v=vs.85).aspx">Naming Files, Paths, and Namespaces</a>. Under NTFS, if the filename contains
a colon, Node.js will open a file system stream, as described by
<a href="https://msdn.microsoft.com/en-us/library/windows/desktop/bb540537.aspx">this MSDN page</a>.</p>
<h2>read - v10.0.0</h2><p>Read data from the file specified by <code>filehandle</code>.</p>
<p><code>buffer</code> is the buffer that the data will be written to.</p>
<p><code>offset</code> is the offset in the buffer to start writing at.</p>
<p><code>length</code> is an integer specifying the number of bytes to read.</p>
<p><code>position</code> is an argument specifying where to begin reading from in the file.
If <code>position</code> is <code>null</code>, data will be read from the current file position,
and the file position will be updated.
If <code>position</code> is an integer, the file position will remain unchanged.</p>
<p>Following successful read, the <code>Promise</code> is resolved with an object with a
<code>bytesRead</code> property specifying the number of bytes read, and a <code>buffer</code>
property that is a reference to the passed in <code>buffer</code> argument.</p>
<h2>readdir - v10.0.0</h2><p>Reads the contents of a directory then resolves the <code>Promise</code> with an array
of the names of the files in the directory excludiing <code>&#39;.&#39;</code> and <code>&#39;..&#39;</code>.</p>
<p>The optional <code>options</code> argument can be a string specifying an encoding, or an
object with an <code>encoding</code> property specifying the character encoding to use for
the filenames. If the <code>encoding</code> is set to <code>&#39;buffer&#39;</code>, the filenames returned
will be passed as <code>Buffer</code> objects.</p>
<h2>readFile - v10.0.0</h2><p>Asynchronously reads the entire contents of a file.</p>
<p>The <code>Promise</code> is resolved with the contents of the file. If no encoding is
specified (using <code>options.encoding</code>), the data is returned as a <code>Buffer</code>
object. Otherwise, the data will be a string.</p>
<p>If <code>options</code> is a string, then it specifies the encoding.</p>
<p>When the <code>path</code> is a directory, the behavior of <code>fsPromises.readFile()</code> is
platform-specific. On macOS, Linux, and Windows, the promise will be rejected
with an error. On FreeBSD, a representation of the directory&#39;s contents will be
returned.</p>
<p>Any specified <code>FileHandle</code> has to support reading.</p>
<h2>readlink - v10.0.0</h2><p>Asynchronous readlink(2). The <code>Promise</code> is resolved with the <code>linkString</code> upon
success.</p>
<p>The optional <code>options</code> argument can be a string specifying an encoding, or an
object with an <code>encoding</code> property specifying the character encoding to use for
the link path returned. If the <code>encoding</code> is set to <code>&#39;buffer&#39;</code>, the link path
returned will be passed as a <code>Buffer</code> object.</p>
<h2>realpath - v10.0.0</h2><p>Determines the actual location of <code>path</code> using the same semantics as the
<code>fs.realpath.native()</code> function then resolves the <code>Promise</code> with the resolved
path.</p>
<p>Only paths that can be converted to UTF8 strings are supported.</p>
<p>The optional <code>options</code> argument can be a string specifying an encoding, or an
object with an <code>encoding</code> property specifying the character encoding to use for
the path. If the <code>encoding</code> is set to <code>&#39;buffer&#39;</code>, the path returned will be
passed as a <code>Buffer</code> object.</p>
<p>On Linux, when Node.js is linked against musl libc, the procfs file system must
be mounted on <code>/proc</code> in order for this function to work. Glibc does not have
this restriction.</p>
<h2>rename - v10.0.0</h2><p>Renames <code>oldPath</code> to <code>newPath</code> and resolves the <code>Promise</code> with no arguments
upon success.</p>
<h2>rmdir - v10.0.0</h2><p>Removes the directory identified by <code>path</code> then resolves the <code>Promise</code> with
no arguments upon success.</p>
<p>Using <code>fsPromises.rmdir()</code> on a file (not a directory) results in the
<code>Promise</code> being rejected with an <code>ENOENT</code> error on Windows and an <code>ENOTDIR</code>
error on POSIX.</p>
<h2>stat - v10.0.0</h2><p>The <code>Promise</code> is resolved with the <a href="#fs_class_fs_stats"><code>fs.Stats</code></a> object for the given <code>path</code>.</p>
<h2>symlink - v10.0.0</h2><p>Creates a symbolic link then resolves the <code>Promise</code> with no arguments upon
success.</p>
<p>The <code>type</code> argument is only used on Windows platforms and can be one of <code>&#39;dir&#39;</code>,
<code>&#39;file&#39;</code>, or <code>&#39;junction&#39;</code>. Note that Windows junction
points require the destination path to be absolute. When using <code>&#39;junction&#39;</code>,
the <code>target</code> argument will automatically be normalized to absolute path.</p>
<h2>truncate - v10.0.0</h2><p>Truncates the <code>path</code> then resolves the <code>Promise</code> with no arguments upon
success. The <code>path</code> <em>must</em> be a string or <code>Buffer</code>.</p>
<h2>unlink - v10.0.0</h2><p>Asynchronous unlink(2). The <code>Promise</code> is resolved with no arguments upon
success.</p>
<h2>utimes - v10.0.0</h2><p>Change the file system timestamps of the object referenced by <code>path</code> then
resolves the <code>Promise</code> with no arguments upon success.</p>
<p>The <code>atime</code> and <code>mtime</code> arguments follow these rules:</p>
<ul>
<li>Values can be either numbers representing Unix epoch time, <code>Date</code>s, or a
numeric string like <code>&#39;123456789.0&#39;</code>.</li>
<li>If the value can not be converted to a number, or is <code>NaN</code>, <code>Infinity</code> or
<code>-Infinity</code>, an <code>Error</code> will be thrown.</li>
</ul>
<h2>write - v10.0.0</h2><p>Write <code>buffer</code> to the file specified by <code>filehandle</code>.</p>
<p>The <code>Promise</code> is resolved with an object containing a <code>bytesWritten</code> property
identifying the number of bytes written, and a <code>buffer</code> property containing
a reference to the <code>buffer</code> written.</p>
<p><code>offset</code> determines the part of the buffer to be written, and <code>length</code> is
an integer specifying the number of bytes to write.</p>
<p><code>position</code> refers to the offset from the beginning of the file where this data
should be written. If <code>typeof position !== &#39;number&#39;</code>, the data will be written
at the current position. See pwrite(2).</p>
<p>It is unsafe to use <code>fsPromises.write()</code> multiple times on the same file
without waiting for the <code>Promise</code> to be resolved (or rejected). For this
scenario, <code>fs.createWriteStream</code> is strongly recommended.</p>
<p>On Linux, positional writes do not work when the file is opened in append mode.
The kernel ignores the position argument and always appends the data to
the end of the file.</p>
<h2>writeFile - v10.0.0</h2><p>Asynchronously writes data to a file, replacing the file if it already exists.
<code>data</code> can be a string or a buffer. The <code>Promise</code> will be resolved with no
arguments upon success.</p>
<p>The <code>encoding</code> option is ignored if <code>data</code> is a buffer.</p>
<p>If <code>options</code> is a string, then it specifies the encoding.</p>
<p>Any specified <code>FileHandle</code> has to support writing.</p>
<p>It is unsafe to use <code>fsPromises.writeFile()</code> multiple times on the same file
without waiting for the <code>Promise</code> to be resolved (or rejected).</p>
<h2>appendFile - v10.0.0</h2><p>Asynchronously append data to a file, creating the file if it does not yet
exist. <code>data</code> can be a string or a <a href="buffer.html#buffer_class_buffer"><code>Buffer</code></a>.</p>
<p>Example:</p>
<pre><code class="lang-js">fs.appendFile(&#39;message.txt&#39;, &#39;data to append&#39;, (err) =&gt; {
  if (err) throw err;
  console.log(&#39;The &quot;data to append&quot; was appended to file!&#39;);
});
</code></pre>
<p>If <code>options</code> is a string, then it specifies the encoding. Example:</p>
<pre><code class="lang-js">fs.appendFile(&#39;message.txt&#39;, &#39;data to append&#39;, &#39;utf8&#39;, callback);
</code></pre>
<p>The <code>path</code> may be specified as a numeric file descriptor that has been opened
for appending (using <code>fs.open()</code> or <code>fs.openSync()</code>). The file descriptor will
not be closed automatically.</p>
<pre><code class="lang-js">fs.open(&#39;message.txt&#39;, &#39;a&#39;, (err, fd) =&gt; {
  if (err) throw err;
  fs.appendFile(fd, &#39;data to append&#39;, &#39;utf8&#39;, (err) =&gt; {
    fs.close(fd, (err) =&gt; {
      if (err) throw err;
    });
    if (err) throw err;
  });
});
</code></pre>
<h2>chmod - v10.0.0</h2><p>Asynchronously changes the permissions of a file. No arguments other than a
possible exception are given to the completion callback.</p>
<p>See also: chmod(2).</p>
<h2>chown - v10.0.0</h2><p>Asynchronously changes owner and group of a file. No arguments other than a
possible exception are given to the completion callback.</p>
<p>See also: chown(2).</p>
<h2>close - v10.0.0</h2><p>Asynchronous close(2). No arguments other than a possible exception are given
to the completion callback.</p>
<h2>fchmod - v10.0.0</h2><p>Asynchronous fchmod(2). No arguments other than a possible exception
are given to the completion callback.</p>
<h2>fchown - v10.0.0</h2><p>Asynchronous fchown(2). No arguments other than a possible exception are given
to the completion callback.</p>
<h2>fdatasync - v10.0.0</h2><p>Asynchronous fdatasync(2). No arguments other than a possible exception are
given to the completion callback.</p>
<h2>fstat - v10.0.0</h2><p>Asynchronous fstat(2). The callback gets two arguments <code>(err, stats)</code> where
<code>stats</code> is an <a href="#fs_class_fs_stats"><code>fs.Stats</code></a> object. <code>fstat()</code> is identical to <a href="fs.html#fs_fs_stat_path_callback"><code>stat()</code></a>,
except that the file to be stat-ed is specified by the file descriptor <code>fd</code>.</p>
<h2>fsync - v10.0.0</h2><p>Asynchronous fsync(2). No arguments other than a possible exception are given
to the completion callback.</p>
<h2>ftruncate - v10.0.0</h2><p>Asynchronous ftruncate(2). No arguments other than a possible exception are
given to the completion callback.</p>
<p>If the file referred to by the file descriptor was larger than <code>len</code> bytes, only
the first <code>len</code> bytes will be retained in the file.</p>
<p>For example, the following program retains only the first four bytes of the
file:</p>
<pre><code class="lang-js">console.log(fs.readFileSync(&#39;temp.txt&#39;, &#39;utf8&#39;));
// Prints: Node.js

// get the file descriptor of the file to be truncated
const fd = fs.openSync(&#39;temp.txt&#39;, &#39;r+&#39;);

// truncate the file to first four bytes
fs.ftruncate(fd, 4, (err) =&gt; {
  assert.ifError(err);
  console.log(fs.readFileSync(&#39;temp.txt&#39;, &#39;utf8&#39;));
});
// Prints: Node
</code></pre>
<p>If the file previously was shorter than <code>len</code> bytes, it is extended, and the
extended part is filled with null bytes (<code>&#39;\0&#39;</code>). For example,</p>
<pre><code class="lang-js">console.log(fs.readFileSync(&#39;temp.txt&#39;, &#39;utf8&#39;));
// Prints: Node.js

// get the file descriptor of the file to be truncated
const fd = fs.openSync(&#39;temp.txt&#39;, &#39;r+&#39;);

// truncate the file to 10 bytes, whereas the actual size is 7 bytes
fs.ftruncate(fd, 10, (err) =&gt; {
  assert.ifError(err);
  console.log(fs.readFileSync(&#39;temp.txt&#39;));
});
// Prints: &lt;Buffer 4e 6f 64 65 2e 6a 73 00 00 00&gt;
// (&#39;Node.js\0\0\0&#39; in UTF8)
</code></pre>
<p>The last three bytes are null bytes (<code>&#39;\0&#39;</code>), to compensate the over-truncation.</p>
<h2>futimes - v10.0.0</h2><p>Change the file system timestamps of the object referenced by the supplied file
descriptor. See <a href="#fs_fs_utimes_path_atime_mtime_callback"><code>fs.utimes()</code></a>.</p>
<p>This function does not work on AIX versions before 7.1, it will return the
error <code>UV_ENOSYS</code>.</p>
<h2>lchmod - v10.0.0</h2><p>Asynchronous lchmod(2). No arguments other than a possible exception
are given to the completion callback.</p>
<p>Only available on macOS.</p>
<h2>lchown - v10.0.0</h2><p>Asynchronous lchown(2). No arguments other than a possible exception are given
to the completion callback.</p>
<h2>link - v10.0.0</h2><p>Asynchronous link(2). No arguments other than a possible exception are given to
the completion callback.</p>
<h2>lstat - v10.0.0</h2><p>Asynchronous lstat(2). The callback gets two arguments <code>(err, stats)</code> where
<code>stats</code> is a <a href="#fs_class_fs_stats"><code>fs.Stats</code></a> object. <code>lstat()</code> is identical to <code>stat()</code>,
except that if <code>path</code> is a symbolic link, then the link itself is stat-ed,
not the file that it refers to.</p>
<h2>mkdir - v10.0.0</h2><p>Asynchronously creates a directory. No arguments other than a possible exception
are given to the completion callback.</p>
<p>See also: mkdir(2).</p>
<h2>mkdtemp - v10.0.0</h2><p>Creates a unique temporary directory.</p>
<p>Generates six random characters to be appended behind a required
<code>prefix</code> to create a unique temporary directory.</p>
<p>The created folder path is passed as a string to the callback&#39;s second
parameter.</p>
<p>The optional <code>options</code> argument can be a string specifying an encoding, or an
object with an <code>encoding</code> property specifying the character encoding to use.</p>
<pre><code class="lang-js">fs.mkdtemp(path.join(os.tmpdir(), &#39;foo-&#39;), (err, folder) =&gt; {
  if (err) throw err;
  console.log(folder);
  // Prints: /tmp/foo-itXde2 or C:\Users\...\AppData\Local\Temp\foo-itXde2
});
</code></pre>
<p>The <code>fs.mkdtemp()</code> method will append the six randomly selected characters
directly to the <code>prefix</code> string. For instance, given a directory <code>/tmp</code>, if the
intention is to create a temporary directory <em>within</em> <code>/tmp</code>, the <code>prefix</code>
must end with a trailing platform-specific path separator
(<code>require(&#39;path&#39;).sep</code>).</p>
<pre><code class="lang-js">// The parent directory for the new temporary directory
const tmpDir = os.tmpdir();

// This method is *INCORRECT*:
fs.mkdtemp(tmpDir, (err, folder) =&gt; {
  if (err) throw err;
  console.log(folder);
  // Will print something similar to `/tmpabc123`.
  // Note that a new temporary directory is created
  // at the file system root rather than *within*
  // the /tmp directory.
});

// This method is *CORRECT*:
const { sep } = require(&#39;path&#39;);
fs.mkdtemp(`${tmpDir}${sep}`, (err, folder) =&gt; {
  if (err) throw err;
  console.log(folder);
  // Will print something similar to `/tmp/abc123`.
  // A new temporary directory is created within
  // the /tmp directory.
});
</code></pre>
<h2>open - v9.9.0</h2><p>Asynchronous file open. See open(2).</p>
<p><code>mode</code> sets the file mode (permission and sticky bits), but only if the file was
created.</p>
<p>The callback gets two arguments <code>(err, fd)</code>.</p>
<p>Some characters (<code>&lt; &gt; : &quot; / \ | ? *</code>) are reserved under Windows as documented
by <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa365247(v=vs.85).aspx">Naming Files, Paths, and Namespaces</a>. Under NTFS, if the filename contains
a colon, Node.js will open a file system stream, as described by
<a href="https://msdn.microsoft.com/en-us/library/windows/desktop/bb540537.aspx">this MSDN page</a>.</p>
<p>Functions based on <code>fs.open()</code> exhibit this behavior as well. eg.
<code>fs.writeFile()</code>, <code>fs.readFile()</code>, etc.</p>
<h2>readdir - v10.0.0</h2><p>Asynchronous readdir(3). Reads the contents of a directory.
The callback gets two arguments <code>(err, files)</code> where <code>files</code> is an array of
the names of the files in the directory excluding <code>&#39;.&#39;</code> and <code>&#39;..&#39;</code>.</p>
<p>The optional <code>options</code> argument can be a string specifying an encoding, or an
object with an <code>encoding</code> property specifying the character encoding to use for
the filenames passed to the callback. If the <code>encoding</code> is set to <code>&#39;buffer&#39;</code>,
the filenames returned will be passed as <code>Buffer</code> objects.</p>
<h2>readFile - v10.0.0</h2><p>Asynchronously reads the entire contents of a file. Example:</p>
<pre><code class="lang-js">fs.readFile(&#39;/etc/passwd&#39;, (err, data) =&gt; {
  if (err) throw err;
  console.log(data);
});
</code></pre>
<p>The callback is passed two arguments <code>(err, data)</code>, where <code>data</code> is the
contents of the file.</p>
<p>If no encoding is specified, then the raw buffer is returned.</p>
<p>If <code>options</code> is a string, then it specifies the encoding. Example:</p>
<pre><code class="lang-js">fs.readFile(&#39;/etc/passwd&#39;, &#39;utf8&#39;, callback);
</code></pre>
<p>When the path is a directory, the behavior of <code>fs.readFile()</code> and
<a href="#fs_fs_readfilesync_path_options"><code>fs.readFileSync()</code></a> is platform-specific. On macOS, Linux, and Windows, an
error will be returned. On FreeBSD, a representation of the directory&#39;s contents
will be returned.</p>
<pre><code class="lang-js">// macOS, Linux, and Windows
fs.readFile(&#39;&lt;directory&gt;&#39;, (err, data) =&gt; {
  // =&gt; [Error: EISDIR: illegal operation on a directory, read &lt;directory&gt;]
});

//  FreeBSD
fs.readFile(&#39;&lt;directory&gt;&#39;, (err, data) =&gt; {
  // =&gt; null, &lt;data&gt;
});
</code></pre>
<p>Any specified file descriptor has to support reading.</p>
<p>If a file descriptor is specified as the <code>path</code>, it will not be closed
automatically.</p>
<p>The <code>fs.readFile()</code> function buffers the entire file. To minimize memory costs,
when possible prefer streaming via <code>fs.createReadStream()</code>.</p>
<h2>readlink - v10.0.0</h2><p>Asynchronous readlink(2). The callback gets two arguments <code>(err,
linkString)</code>.</p>
<p>The optional <code>options</code> argument can be a string specifying an encoding, or an
object with an <code>encoding</code> property specifying the character encoding to use for
the link path passed to the callback. If the <code>encoding</code> is set to <code>&#39;buffer&#39;</code>,
the link path returned will be passed as a <code>Buffer</code> object.</p>
<h2>realpath - v10.0.0</h2><p>Asynchronously computes the canonical pathname by resolving <code>.</code>, <code>..</code> and
symbolic links.</p>
<p>Note that &quot;canonical&quot; does not mean &quot;unique&quot;: hard links and bind mounts can
expose a file system entity through many pathnames.</p>
<p>This function behaves like realpath(3), with some exceptions:</p>
<ol>
<li><p>No case conversion is performed on case-insensitive file systems.</p>
</li>
<li><p>The maximum number of symbolic links is platform-independent and generally
(much) higher than what the native realpath(3) implementation supports.</p>
</li>
</ol>
<p>The <code>callback</code> gets two arguments <code>(err, resolvedPath)</code>. May use <code>process.cwd</code>
to resolve relative paths.</p>
<p>Only paths that can be converted to UTF8 strings are supported.</p>
<p>The optional <code>options</code> argument can be a string specifying an encoding, or an
object with an <code>encoding</code> property specifying the character encoding to use for
the path passed to the callback. If the <code>encoding</code> is set to <code>&#39;buffer&#39;</code>,
the path returned will be passed as a <code>Buffer</code> object.</p>
<p>If <code>path</code> resolves to a socket or a pipe, the function will return a system
dependent name for that object.</p>
<h2>native - v9.2.0</h2><p>Asynchronous realpath(3).</p>
<p>The <code>callback</code> gets two arguments <code>(err, resolvedPath)</code>.</p>
<p>Only paths that can be converted to UTF8 strings are supported.</p>
<p>The optional <code>options</code> argument can be a string specifying an encoding, or an
object with an <code>encoding</code> property specifying the character encoding to use for
the path passed to the callback. If the <code>encoding</code> is set to <code>&#39;buffer&#39;</code>,
the path returned will be passed as a <code>Buffer</code> object.</p>
<p>On Linux, when Node.js is linked against musl libc, the procfs file system must
be mounted on <code>/proc</code> in order for this function to work. Glibc does not have
this restriction.</p>
<h2>native - v9.2.0</h2><p>Synchronous realpath(3).</p>
<p>Only paths that can be converted to UTF8 strings are supported.</p>
<p>The optional <code>options</code> argument can be a string specifying an encoding, or an
object with an <code>encoding</code> property specifying the character encoding to use for
the path passed to the callback. If the <code>encoding</code> is set to <code>&#39;buffer&#39;</code>,
the path returned will be passed as a <code>Buffer</code> object.</p>
<p>On Linux, when Node.js is linked against musl libc, the procfs file system must
be mounted on <code>/proc</code> in order for this function to work. Glibc does not have
this restriction.</p>
<h2>rename - v10.0.0</h2><p>Asynchronously rename file at <code>oldPath</code> to the pathname provided
as <code>newPath</code>. In the case that <code>newPath</code> already exists, it will
be overwritten. No arguments other than a possible exception are
given to the completion callback.</p>
<p>See also: rename(2).</p>
<pre><code class="lang-js">fs.rename(&#39;oldFile.txt&#39;, &#39;newFile.txt&#39;, (err) =&gt; {
  if (err) throw err;
  console.log(&#39;Rename complete!&#39;);
});
</code></pre>
<h2>rmdir - v10.0.0</h2><p>Asynchronous rmdir(2). No arguments other than a possible exception are given
to the completion callback.</p>
<p>Using <code>fs.rmdir()</code> on a file (not a directory) results in an <code>ENOENT</code> error on
Windows and an <code>ENOTDIR</code> error on POSIX.</p>
<h2>stat - v10.0.0</h2><p>Asynchronous stat(2). The callback gets two arguments <code>(err, stats)</code> where
<code>stats</code> is an <a href="#fs_class_fs_stats"><code>fs.Stats</code></a> object.</p>
<p>In case of an error, the <code>err.code</code> will be one of <a href="errors.html#errors_common_system_errors">Common System Errors</a>.</p>
<p>Using <code>fs.stat()</code> to check for the existence of a file before calling
<code>fs.open()</code>, <code>fs.readFile()</code> or <code>fs.writeFile()</code> is not recommended.
Instead, user code should open/read/write the file directly and handle the
error raised if the file is not available.</p>
<p>To check if a file exists without manipulating it afterwards, <a href="#fs_fs_access_path_mode_callback"><code>fs.access()</code></a>
is recommended.</p>
<h2>truncate - v10.0.0</h2><p>Asynchronous truncate(2). No arguments other than a possible exception are
given to the completion callback. A file descriptor can also be passed as the
first argument. In this case, <code>fs.ftruncate()</code> is called.</p>
<p>Passing a file descriptor is deprecated and may result in an error being thrown
in the future.</p>
<h2>unlink - v10.0.0</h2><p>Asynchronously removes a file or symbolic link. No arguments other than a
possible exception are given to the completion callback.</p>
<pre><code class="lang-js">// Assuming that &#39;path/file.txt&#39; is a regular file.
fs.unlink(&#39;path/file.txt&#39;, (err) =&gt; {
  if (err) throw err;
  console.log(&#39;path/file.txt was deleted&#39;);
});
</code></pre>
<p><code>fs.unlink()</code> will not work on a directory, empty or otherwise. To remove a
directory, use <a href="#fs_fs_rmdir_path_callback"><code>fs.rmdir()</code></a>.</p>
<p>See also: unlink(2).</p>
<h2>utimes - v10.0.0</h2><p>Change the file system timestamps of the object referenced by <code>path</code>.</p>
<p>The <code>atime</code> and <code>mtime</code> arguments follow these rules:</p>
<ul>
<li>Values can be either numbers representing Unix epoch time, <code>Date</code>s, or a
numeric string like <code>&#39;123456789.0&#39;</code>.</li>
<li>If the value can not be converted to a number, or is <code>NaN</code>, <code>Infinity</code> or
<code>-Infinity</code>, an <code>Error</code> will be thrown.</li>
</ul>
<h2>write - v10.0.0</h2><p>Write <code>buffer</code> to the file specified by <code>fd</code>.</p>
<p><code>offset</code> determines the part of the buffer to be written, and <code>length</code> is
an integer specifying the number of bytes to write.</p>
<p><code>position</code> refers to the offset from the beginning of the file where this data
should be written. If <code>typeof position !== &#39;number&#39;</code>, the data will be written
at the current position. See pwrite(2).</p>
<p>The callback will be given three arguments <code>(err, bytesWritten, buffer)</code> where
<code>bytesWritten</code> specifies how many <em>bytes</em> were written from <code>buffer</code>.</p>
<p>If this method is invoked as its <a href="#util_util_promisify_original"><code>util.promisify()</code></a>ed version, it returns
a <code>Promise</code> for an <code>Object</code> with <code>bytesWritten</code> and <code>buffer</code> properties.</p>
<p>Note that it is unsafe to use <code>fs.write</code> multiple times on the same file
without waiting for the callback. For this scenario,
<code>fs.createWriteStream</code> is strongly recommended.</p>
<p>On Linux, positional writes don&#39;t work when the file is opened in append mode.
The kernel ignores the position argument and always appends the data to
the end of the file.</p>
<h2>write - v10.0.0</h2><p>Write <code>string</code> to the file specified by <code>fd</code>. If <code>string</code> is not a string, then
the value will be coerced to one.</p>
<p><code>position</code> refers to the offset from the beginning of the file where this data
should be written. If <code>typeof position !== &#39;number&#39;</code> the data will be written at
the current position. See pwrite(2).</p>
<p><code>encoding</code> is the expected string encoding.</p>
<p>The callback will receive the arguments <code>(err, written, string)</code> where <code>written</code>
specifies how many <em>bytes</em> the passed string required to be written. Note that
bytes written is not the same as string characters. See <a href="buffer.html#buffer_class_method_buffer_bytelength_string_encoding"><code>Buffer.byteLength</code></a>.</p>
<p>Note that it is unsafe to use <code>fs.write</code> multiple times on the same file
without waiting for the callback. For this scenario,
<code>fs.createWriteStream</code> is strongly recommended.</p>
<p>On Linux, positional writes don&#39;t work when the file is opened in append mode.
The kernel ignores the position argument and always appends the data to
the end of the file.</p>
<h2>writeFile - v10.0.0</h2><p>Asynchronously writes data to a file, replacing the file if it already exists.
<code>data</code> can be a string or a buffer.</p>
<p>The <code>encoding</code> option is ignored if <code>data</code> is a buffer.</p>
<p>Example:</p>
<pre><code class="lang-js">fs.writeFile(&#39;message.txt&#39;, &#39;Hello Node.js&#39;, (err) =&gt; {
  if (err) throw err;
  console.log(&#39;The file has been saved!&#39;);
});
</code></pre>
<p>If <code>options</code> is a string, then it specifies the encoding. Example:</p>
<pre><code class="lang-js">fs.writeFile(&#39;message.txt&#39;, &#39;Hello Node.js&#39;, &#39;utf8&#39;, callback);
</code></pre>
<p>Any specified file descriptor has to support writing.</p>
<p>Note that it is unsafe to use <code>fs.writeFile</code> multiple times on the same file
without waiting for the callback. For this scenario,
<code>fs.createWriteStream</code> is strongly recommended.</p>
<p>If a file descriptor is specified as the <code>file</code>, it will not be closed
automatically.</p>
<h2>end - v10.0.0</h2><p>Finishes sending the request. If any parts of the body are
unsent, it will flush them to the stream. If the request is
chunked, this will send the terminating <code>&#39;0\r\n\r\n&#39;</code>.</p>
<p>If <code>data</code> is specified, it is equivalent to calling
<a href="#http_request_write_chunk_encoding_callback"><code>request.write(data, encoding)</code></a> followed by <code>request.end(callback)</code>.</p>
<p>If <code>callback</code> is specified, it will be called when the request stream
is finished.</p>
<h2>end - v10.0.0</h2><p>This method signals to the server that all of the response headers and body
have been sent; that server should consider this message complete.
The method, <code>response.end()</code>, MUST be called on each response.</p>
<p>If <code>data</code> is specified, it is equivalent to calling
<a href="http.html#http_response_write_chunk_encoding_callback"><code>response.write(data, encoding)</code></a> followed by <code>response.end(callback)</code>.</p>
<p>If <code>callback</code> is specified, it will be called when the response stream
is finished.</p>
<h2>writeProcessing - v10.0.0</h2><p>Sends a HTTP/1.1 102 Processing message to the client, indicating that
the request body should be sent.</p>
<h2>createServer - v9.6.0</h2><p>Returns a new instance of <a href="http.html#http_class_http_server"><code>http.Server</code></a>.</p>
<p>The <code>requestListener</code> is a function which is automatically
added to the <a href="#http2_event_request"><code>&#39;request&#39;</code></a> event.</p>
<h2>close - v9.4.0</h2><p>Gracefully closes the <code>Http2Session</code>, allowing any existing streams to
complete on their own and preventing new <code>Http2Stream</code> instances from being
created. Once closed, <code>http2session.destroy()</code> <em>might</em> be called if there
are no open <code>Http2Stream</code> instances.</p>
<p>If specified, the <code>callback</code> function is registered as a handler for the
<code>&#39;close&#39;</code> event.</p>
<h2>goaway - v9.4.0</h2><p>Transmits a <code>GOAWAY</code> frame to the connected peer <em>without</em> shutting down the
<code>Http2Session</code>.</p>
<h2>ref - v9.4.0</h2><p>Calls <a href="net.html#net_socket_ref"><code>ref()</code></a> on this <code>Http2Session</code>
instance&#39;s underlying <a href="net.html#net_class_net_socket"><code>net.Socket</code></a>.</p>
<h2>unref - v9.4.0</h2><p>Calls <a href="net.html#net_socket_unref"><code>unref()</code></a> on this <code>Http2Session</code>
instance&#39;s underlying <a href="net.html#net_class_net_socket"><code>net.Socket</code></a>.</p>
<h2>altsvc - v9.4.0</h2><p>Submits an <code>ALTSVC</code> frame (as defined by <a href="https://tools.ietf.org/html/rfc7838">RFC 7838</a>) to the connected client.</p>
<pre><code class="lang-js">const http2 = require(&#39;http2&#39;);

const server = http2.createServer();
server.on(&#39;session&#39;, (session) =&gt; {
  // Set altsvc for origin https://example.org:80
  session.altsvc(&#39;h2=&quot;:8000&quot;&#39;, &#39;https://example.org:80&#39;);
});

server.on(&#39;stream&#39;, (stream) =&gt; {
  // Set altsvc for a specific stream
  stream.session.altsvc(&#39;h2=&quot;:8000&quot;&#39;, stream.id);
});
</code></pre>
<p>Sending an <code>ALTSVC</code> frame with a specific stream ID indicates that the alternate
service is associated with the origin of the given <code>Http2Stream</code>.</p>
<p>The <code>alt</code> and origin string <em>must</em> contain only ASCII bytes and are
strictly interpreted as a sequence of ASCII bytes. The special value <code>&#39;clear&#39;</code>
may be passed to clear any previously set alternative service for a given
domain.</p>
<p>When a string is passed for the <code>originOrStream</code> argument, it will be parsed as
a URL and the origin will be derived. For instance, the origin for the
HTTP URL <code>&#39;https://example.org/foo/bar&#39;</code> is the ASCII string
<code>&#39;https://example.org&#39;</code>. An error will be thrown if either the given string
cannot be parsed as a URL or if a valid origin cannot be derived.</p>
<p>A <code>URL</code> object, or any object with an <code>origin</code> property, may be passed as
<code>originOrStream</code>, in which case the value of the <code>origin</code> property will be
used. The value of the <code>origin</code> property <em>must</em> be a properly serialized
ASCII origin.</p>
<h2>sendTrailers - v10.0.0</h2><p>Sends a trailing <code>HEADERS</code> frame to the connected HTTP/2 peer. This method
will cause the <code>Http2Stream</code> to be immediately closed and must only be
called after the <code>&#39;wantTrailers&#39;</code>  event has been emitted. When sending a
request or sending a response, the <code>options.waitForTrailers</code> option must be set
in order to keep the <code>Http2Stream</code> open after the final <code>DATA</code> frame so that
trailers can be sent.</p>
<pre><code class="lang-js">const http2 = require(&#39;http2&#39;);
const server = http2.createServer();
server.on(&#39;stream&#39;, (stream) =&gt; {
  stream.respond(undefined, { waitForTrailers: true });
  stream.on(&#39;wantTrailers&#39;, () =&gt; {
    stream.sendTrailers({ xyz: &#39;abc&#39; });
  });
  stream.end(&#39;Hello World&#39;);
});
</code></pre>
<p>The HTTP/1 specification forbids trailers from containing HTTP/2 pseudo-header
fields (e.g. <code>&#39;:method&#39;</code>, <code>&#39;:path&#39;</code>, etc).</p>
<h2>respondWithFD - v10.0.0</h2><p>Initiates a response whose data is read from the given file descriptor. No
validation is performed on the given file descriptor. If an error occurs while
attempting to read data using the file descriptor, the <code>Http2Stream</code> will be
closed using an <code>RST_STREAM</code> frame using the standard <code>INTERNAL_ERROR</code> code.</p>
<p>When used, the <code>Http2Stream</code> object&#39;s <code>Duplex</code> interface will be closed
automatically.</p>
<pre><code class="lang-js">const http2 = require(&#39;http2&#39;);
const fs = require(&#39;fs&#39;);

const server = http2.createServer();
server.on(&#39;stream&#39;, (stream) =&gt; {
  const fd = fs.openSync(&#39;/some/file&#39;, &#39;r&#39;);

  const stat = fs.fstatSync(fd);
  const headers = {
    &#39;content-length&#39;: stat.size,
    &#39;last-modified&#39;: stat.mtime.toUTCString(),
    &#39;content-type&#39;: &#39;text/plain&#39;
  };
  stream.respondWithFD(fd, headers);
  stream.on(&#39;close&#39;, () =&gt; fs.closeSync(fd));
});
</code></pre>
<p>The optional <code>options.statCheck</code> function may be specified to give user code
an opportunity to set additional content headers based on the <code>fs.Stat</code> details
of the given fd. If the <code>statCheck</code> function is provided, the
<code>http2stream.respondWithFD()</code> method will perform an <code>fs.fstat()</code> call to
collect details on the provided file descriptor.</p>
<p>The <code>offset</code> and <code>length</code> options may be used to limit the response to a
specific range subset. This can be used, for instance, to support HTTP Range
requests.</p>
<p>The file descriptor is not closed when the stream is closed, so it will need
to be closed manually once it is no longer needed.
Note that using the same file descriptor concurrently for multiple streams
is not supported and may result in data loss. Re-using a file descriptor
after a stream has finished is supported.</p>
<p>When the <code>options.waitForTrailers</code> option is set, the <code>&#39;wantTrailers&#39;</code> event
will be emitted immediately after queuing the last chunk of payload data to be
sent. The <code>http2stream.sendTrailers()</code> method can then be used to sent trailing
header fields to the peer.</p>
<p>It is important to note that when <code>options.waitForTrailers</code> is set, the
<code>Http2Stream</code> will <em>not</em> automatically close when the final <code>DATA</code> frame is
transmitted. User code <em>must</em> call either <code>http2stream.sendTrailers()</code> or
<code>http2stream.close()</code> to close the <code>Http2Stream</code>.</p>
<pre><code class="lang-js">const http2 = require(&#39;http2&#39;);
const fs = require(&#39;fs&#39;);

const server = http2.createServer();
server.on(&#39;stream&#39;, (stream) =&gt; {
  const fd = fs.openSync(&#39;/some/file&#39;, &#39;r&#39;);

  const stat = fs.fstatSync(fd);
  const headers = {
    &#39;content-length&#39;: stat.size,
    &#39;last-modified&#39;: stat.mtime.toUTCString(),
    &#39;content-type&#39;: &#39;text/plain&#39;
  };
  stream.respondWithFD(fd, headers, { waitForTrailers: true });
  stream.on(&#39;wantTrailers&#39;, () =&gt; {
    stream.sendTrailers({ ABC: &#39;some value to send&#39; });
  });

  stream.on(&#39;close&#39;, () =&gt; fs.closeSync(fd));
});
</code></pre>
<h2>respondWithFile - v10.0.0</h2><p>Sends a regular file as the response. The <code>path</code> must specify a regular file
or an <code>&#39;error&#39;</code> event will be emitted on the <code>Http2Stream</code> object.</p>
<p>When used, the <code>Http2Stream</code> object&#39;s <code>Duplex</code> interface will be closed
automatically.</p>
<p>The optional <code>options.statCheck</code> function may be specified to give user code
an opportunity to set additional content headers based on the <code>fs.Stat</code> details
of the given file:</p>
<p>If an error occurs while attempting to read the file data, the <code>Http2Stream</code>
will be closed using an <code>RST_STREAM</code> frame using the standard <code>INTERNAL_ERROR</code>
code. If the <code>onError</code> callback is defined, then it will be called. Otherwise
the stream will be destroyed.</p>
<p>Example using a file path:</p>
<pre><code class="lang-js">const http2 = require(&#39;http2&#39;);
const server = http2.createServer();
server.on(&#39;stream&#39;, (stream) =&gt; {
  function statCheck(stat, headers) {
    headers[&#39;last-modified&#39;] = stat.mtime.toUTCString();
  }

  function onError(err) {
    if (err.code === &#39;ENOENT&#39;) {
      stream.respond({ &#39;:status&#39;: 404 });
    } else {
      stream.respond({ &#39;:status&#39;: 500 });
    }
    stream.end();
  }

  stream.respondWithFile(&#39;/some/file&#39;,
                         { &#39;content-type&#39;: &#39;text/plain&#39; },
                         { statCheck, onError });
});
</code></pre>
<p>The <code>options.statCheck</code> function may also be used to cancel the send operation
by returning <code>false</code>. For instance, a conditional request may check the stat
results to determine if the file has been modified to return an appropriate
<code>304</code> response:</p>
<pre><code class="lang-js">const http2 = require(&#39;http2&#39;);
const server = http2.createServer();
server.on(&#39;stream&#39;, (stream) =&gt; {
  function statCheck(stat, headers) {
    // Check the stat here...
    stream.respond({ &#39;:status&#39;: 304 });
    return false; // Cancel the send operation
  }
  stream.respondWithFile(&#39;/some/file&#39;,
                         { &#39;content-type&#39;: &#39;text/plain&#39; },
                         { statCheck });
});
</code></pre>
<p>The <code>content-length</code> header field will be automatically set.</p>
<p>The <code>offset</code> and <code>length</code> options may be used to limit the response to a
specific range subset. This can be used, for instance, to support HTTP Range
requests.</p>
<p>The <code>options.onError</code> function may also be used to handle all the errors
that could happen before the delivery of the file is initiated. The
default behavior is to destroy the stream.</p>
<p>When the <code>options.waitForTrailers</code> option is set, the <code>&#39;wantTrailers&#39;</code> event
will be emitted immediately after queuing the last chunk of payload data to be
sent. The <code>http2stream.sendTrilers()</code> method can then be used to sent trailing
header fields to the peer.</p>
<p>It is important to note that when <code>options.waitForTrailers</code> is set, the
<code>Http2Stream</code> will <em>not</em> automatically close when the final <code>DATA</code> frame is
transmitted. User code <em>must</em> call either <code>http2stream.sendTrailers()</code> or
<code>http2stream.close()</code> to close the <code>Http2Stream</code>.</p>
<pre><code class="lang-js">const http2 = require(&#39;http2&#39;);
const server = http2.createServer();
server.on(&#39;stream&#39;, (stream) =&gt; {
  stream.respondWithFile(&#39;/some/file&#39;,
                         { &#39;content-type&#39;: &#39;text/plain&#39; },
                         { waitForTrailers: true });
  stream.on(&#39;wantTrailers&#39;, () =&gt; {
    stream.sendTrailers({ ABC: &#39;some value to send&#39; });
  });
});
</code></pre>
<h2>end - v10.0.0</h2><p>This method signals to the server that all of the response headers and body
have been sent; that server should consider this message complete.
The method, <code>response.end()</code>, MUST be called on each response.</p>
<p>If <code>data</code> is specified, it is equivalent to calling
<a href="http.html#http_response_write_chunk_encoding_callback"><code>response.write(data, encoding)</code></a> followed by <code>response.end(callback)</code>.</p>
<p>If <code>callback</code> is specified, it will be called when the response stream
is finished.</p>
<h2>request - v9.3.0</h2><p>Makes a request to a secure web server.</p>
<p>The following additional <code>options</code> from <a href="#tls_tls_connect_options_callback"><code>tls.connect()</code></a> are also accepted:
<code>ca</code>, <code>cert</code>, <code>ciphers</code>, <code>clientCertEngine</code>, <code>crl</code>, <code>dhparam</code>, <code>ecdhCurve</code>,
<code>honorCipherOrder</code>, <code>key</code>, <code>passphrase</code>, <code>pfx</code>, <code>rejectUnauthorized</code>,
<code>secureOptions</code>, <code>secureProtocol</code>, <code>servername</code>, <code>sessionIdContext</code>.</p>
<p><code>options</code> can be an object, a string, or a <a href="url.html#url_class_url"><code>URL</code></a> object. If <code>options</code> is a
string, it is automatically parsed with <a href="#url_url_parse_urlstring_parsequerystring_slashesdenotehost"><code>url.parse()</code></a>. If it is a <a href="url.html#url_class_url"><code>URL</code></a>
object, it will be automatically converted to an ordinary <code>options</code> object.</p>
<p>Example:</p>
<pre><code class="lang-js">const https = require(&#39;https&#39;);

const options = {
  hostname: &#39;encrypted.google.com&#39;,
  port: 443,
  path: &#39;/&#39;,
  method: &#39;GET&#39;
};

const req = https.request(options, (res) =&gt; {
  console.log(&#39;statusCode:&#39;, res.statusCode);
  console.log(&#39;headers:&#39;, res.headers);

  res.on(&#39;data&#39;, (d) =&gt; {
    process.stdout.write(d);
  });
});

req.on(&#39;error&#39;, (e) =&gt; {
  console.error(e);
});
req.end();
</code></pre>
<p>Example using options from <a href="#tls_tls_connect_options_callback"><code>tls.connect()</code></a>:</p>
<pre><code class="lang-js">const options = {
  hostname: &#39;encrypted.google.com&#39;,
  port: 443,
  path: &#39;/&#39;,
  method: &#39;GET&#39;,
  key: fs.readFileSync(&#39;test/fixtures/keys/agent2-key.pem&#39;),
  cert: fs.readFileSync(&#39;test/fixtures/keys/agent2-cert.pem&#39;)
};
options.agent = new https.Agent(options);

const req = https.request(options, (res) =&gt; {
  // ...
});
</code></pre>
<p>Alternatively, opt out of connection pooling by not using an <a href="#https_class_https_agent"><code>Agent</code></a>.</p>
<p>Example:</p>
<pre><code class="lang-js">const options = {
  hostname: &#39;encrypted.google.com&#39;,
  port: 443,
  path: &#39;/&#39;,
  method: &#39;GET&#39;,
  key: fs.readFileSync(&#39;test/fixtures/keys/agent2-key.pem&#39;),
  cert: fs.readFileSync(&#39;test/fixtures/keys/agent2-cert.pem&#39;),
  agent: false
};

const req = https.request(options, (res) =&gt; {
  // ...
});
</code></pre>
<p>Example using a <a href="url.html#url_class_url"><code>URL</code></a> as <code>options</code>:</p>
<pre><code class="lang-js">const options = new URL(&#39;https://abc:xyz@example.com&#39;);

const req = https.request(options, (res) =&gt; {
  // ...
});
</code></pre>
<p>Example pinning on certificate fingerprint, or the public key (similar to
<code>pin-sha256</code>):</p>
<pre><code class="lang-js">const tls = require(&#39;tls&#39;);
const https = require(&#39;https&#39;);
const crypto = require(&#39;crypto&#39;);

function sha256(s) {
  return crypto.createHash(&#39;sha256&#39;).update(s).digest(&#39;base64&#39;);
}
const options = {
  hostname: &#39;github.com&#39;,
  port: 443,
  path: &#39;/&#39;,
  method: &#39;GET&#39;,
  checkServerIdentity: function(host, cert) {
    // Make sure the certificate is issued to the host we are connected to
    const err = tls.checkServerIdentity(host, cert);
    if (err) {
      return err;
    }

    // Pin the public key, similar to HPKP pin-sha25 pinning
    const pubkey256 = &#39;pL1+qb9HTMRZJmuC/bB/ZI9d302BYrrqiVuRyW+DGrU=&#39;;
    if (sha256(cert.pubkey) !== pubkey256) {
      const msg = &#39;Certificate verification error: &#39; +
        `The public key of &#39;${cert.subject.CN}&#39; ` +
        &#39;does not match our pinned fingerprint&#39;;
      return new Error(msg);
    }

    // Pin the exact certificate, rather then the pub key
    const cert256 = &#39;25:FE:39:32:D9:63:8C:8A:FC:A1:9A:29:87:&#39; +
      &#39;D8:3E:4C:1D:98:DB:71:E4:1A:48:03:98:EA:22:6A:BD:8B:93:16&#39;;
    if (cert.fingerprint256 !== cert256) {
      const msg = &#39;Certificate verification error: &#39; +
        `The certificate of &#39;${cert.subject.CN}&#39; ` +
        &#39;does not match our pinned fingerprint&#39;;
      return new Error(msg);
    }

    // This loop is informational only.
    // Print the certificate and public key fingerprints of all certs in the
    // chain. Its common to pin the public key of the issuer on the public
    // internet, while pinning the public key of the service in sensitive
    // environments.
    do {
      console.log(&#39;Subject Common Name:&#39;, cert.subject.CN);
      console.log(&#39;  Certificate SHA256 fingerprint:&#39;, cert.fingerprint256);

      hash = crypto.createHash(&#39;sha256&#39;);
      console.log(&#39;  Public key ping-sha256:&#39;, sha256(cert.pubkey));

      lastprint256 = cert.fingerprint256;
      cert = cert.issuerCertificate;
    } while (cert.fingerprint256 !== lastprint256);

  },
};

options.agent = new https.Agent(options);
const req = https.request(options, (res) =&gt; {
  console.log(&#39;All OK. Server matched our pinned cert or public key&#39;);
  console.log(&#39;statusCode:&#39;, res.statusCode);
  // Print the HPKP values
  console.log(&#39;headers:&#39;, res.headers[&#39;public-key-pins&#39;]);

  res.on(&#39;data&#39;, (d) =&gt; {});
});

req.on(&#39;error&#39;, (e) =&gt; {
  console.error(e.message);
});
req.end();
</code></pre>
<p>Outputs for example:</p>
<pre><code class="lang-text">Subject Common Name: github.com
  Certificate SHA256 fingerprint: 25:FE:39:32:D9:63:8C:8A:FC:A1:9A:29:87:D8:3E:4C:1D:98:DB:71:E4:1A:48:03:98:EA:22:6A:BD:8B:93:16
  Public key ping-sha256: pL1+qb9HTMRZJmuC/bB/ZI9d302BYrrqiVuRyW+DGrU=
Subject Common Name: DigiCert SHA2 Extended Validation Server CA
  Certificate SHA256 fingerprint: 40:3E:06:2A:26:53:05:91:13:28:5B:AF:80:A0:D4:AE:42:2C:84:8C:9F:78:FA:D0:1F:C9:4B:C5:B8:7F:EF:1A
  Public key ping-sha256: RRM1dGqnDFsCJXBTHky16vi1obOlCgFFn/yOhI/y+ho=
Subject Common Name: DigiCert High Assurance EV Root CA
  Certificate SHA256 fingerprint: 74:31:E5:F4:C3:C1:CE:46:90:77:4F:0B:61:E0:54:40:88:3B:A9:A0:1E:D0:0B:A6:AB:D7:80:6E:D3:B1:18:CF
  Public key ping-sha256: WoiWRyIOVNa9ihaBciRSC7XHjliYS9VwUGOIud4PB18=
All OK. Server matched our pinned cert or public key
statusCode: 200
headers: max-age=0; pin-sha256=&quot;WoiWRyIOVNa9ihaBciRSC7XHjliYS9VwUGOIud4PB18=&quot;; pin-sha256=&quot;RRM1dGqnDFsCJXBTHky16vi1obOlCgFFn/yOhI/y+ho=&quot;; pin-sha256=&quot;k2v657xBsOVe1PQRwOsHsw3bsGT2VzIqz5K+59sNQws=&quot;; pin-sha256=&quot;K87oWBWM9UZfyddvDfoxL+8lpNyoUB2ptGtn0fv6G2Q=&quot;; pin-sha256=&quot;IQBnNBEiFuhj+8x6X8XLgh01V9Ic5/V3IRQLNFFc7v4=&quot;; pin-sha256=&quot;iie1VXtL7HzAMF+/PVPR9xzT80kQxdZeJ+zduCB3uj0=&quot;; pin-sha256=&quot;LvRiGEjRqfzurezaWuj8Wie2gyHMrW5Q06LspMnox7A=&quot;; includeSubDomains
</code></pre>
<!-- [end-include:https.md] -->
<!-- [start-include:inspector.md] -->
<h2>uptime - v10.0.0</h2><p>The <code>os.uptime()</code> method returns the system uptime in number of seconds.</p>
<h2>assignment_of_the_`_`_(underscore)_variable - v9.8.0</h2><p>The default evaluator will, by default, assign the result of the most recently
evaluated expression to the special variable <code>_</code> (underscore).
Explicitly setting <code>_</code> to a value will disable this behavior.</p>
<!-- eslint-skip -->
<pre><code class="lang-js">&gt; [ &#39;a&#39;, &#39;b&#39;, &#39;c&#39; ]
[ &#39;a&#39;, &#39;b&#39;, &#39;c&#39; ]
&gt; _.length
3
&gt; _ += 1
Expression assignment to _ now disabled.
4
&gt; 1 + 1
2
&gt; _
4
</code></pre>
<p>Similarly, <code>_error</code> will refer to the last seen error, if there was any.
Explicitly setting <code>_error</code> to a value will disable this behavior.</p>
<!-- eslint-skip -->
<pre><code class="lang-js">&gt; throw new Error(&#39;foo&#39;);
Error: foo
&gt; _error.message
&#39;foo&#39;
</code></pre>
<h2>start - v10.0.0</h2><p>The <code>repl.start()</code> method creates and starts a <code>repl.REPLServer</code> instance.</p>
<p>If <code>options</code> is a string, then it specifies the input prompt:</p>
<pre><code class="lang-js">const repl = require(&#39;repl&#39;);

// a Unix style prompt
repl.start(&#39;$ &#39;);
</code></pre>
<h2>end - v10.0.0</h2><p>Calling the <code>writable.end()</code> method signals that no more data will be written
to the <a href="#stream_class_stream_writable"><code>Writable</code></a>. The optional <code>chunk</code> and <code>encoding</code> arguments allow one
final additional chunk of data to be written immediately before closing the
stream. If provided, the optional <code>callback</code> function is attached as a listener
for the <a href="#stream_event_finish"><code>&#39;finish&#39;</code></a> event.</p>
<p>Calling the <a href="#stream_writable_write_chunk_encoding_callback"><code>stream.write()</code></a> method after calling
<a href="#stream_writable_end_chunk_encoding_callback"><code>stream.end()</code></a> will raise an error.</p>
<pre><code class="lang-js">// write &#39;hello, &#39; and then end with &#39;world!&#39;
const fs = require(&#39;fs&#39;);
const file = fs.createWriteStream(&#39;example.txt&#39;);
file.write(&#39;hello, &#39;);
file.end(&#39;world!&#39;);
// writing more now is not allowed!
</code></pre>
<h2>resume - v10.0.0</h2><p>The <code>readable.resume()</code> method causes an explicitly paused <code>Readable</code> stream to
resume emitting <a href="#stream_event_data"><code>&#39;data&#39;</code></a> events, switching the stream into flowing mode.</p>
<p>The <code>readable.resume()</code> method can be used to fully consume the data from a
stream without actually processing any of that data as illustrated in the
following example:</p>
<pre><code class="lang-js">getReadableStreamSomehow()
  .resume()
  .on(&#39;end&#39;, () =&gt; {
    console.log(&#39;Reached the end, but did not read anything.&#39;);
  });
</code></pre>
<p>The <code>readable.resume()</code> method has no effect if there is a <code>&#39;readable&#39;</code>
event listener.</p>
<h2>\[Symbol.asyncIterator\] - v10.0.0</h2><pre><code class="lang-js">const fs = require(&#39;fs&#39;);

async function print(readable) {
  readable.setEncoding(&#39;utf8&#39;);
  let data = &#39;&#39;;
  for await (const k of readable) {
    data += k;
  }
  console.log(data);
}

print(fs.createReadStream(&#39;file&#39;)).catch(console.log);
</code></pre>
<p>If the loop terminates with a <code>break</code> or a <code>throw</code>, the stream will be
destroyed. In other terms, iterating over a stream will consume the stream
fully. The stream will be read in chunks of size equal to the <code>highWaterMark</code>
option. In the code example above, data will be in a single chunk if the file
has less then 64kb of data because no <code>highWaterMark</code> option is provided to
<a href="fs.html#fs_fs_createreadstream_path_options"><code>fs.createReadStream()</code></a>.</p>
<h2>finished - v10.0.0</h2><p>A function to get notified when a stream is no longer readable, writable
or has experienced an error or a premature close event.</p>
<pre><code class="lang-js">const { finished } = require(&#39;stream&#39;);

const rs = fs.createReadStream(&#39;archive.tar&#39;);

finished(rs, (err) =&gt; {
  if (err) {
    console.error(&#39;Stream failed&#39;, err);
  } else {
    console.log(&#39;Stream is done reading&#39;);
  }
});

rs.resume(); // drain the stream
</code></pre>
<p>Especially useful in error handling scenarios where a stream is destroyed
prematurely (like an aborted HTTP request), and will not emit <code>&#39;end&#39;</code>
or <code>&#39;finish&#39;</code>.</p>
<p>The <code>finished</code> API is promisify&#39;able as well;</p>
<pre><code class="lang-js">const finished = util.promisify(stream.finished);

const rs = fs.createReadStream(&#39;archive.tar&#39;);

async function run() {
  await finished(rs);
  console.log(&#39;Stream is done reading&#39;);
}

run().catch(console.error);
rs.resume(); // drain the stream
</code></pre>
<h2>pipeline - v10.0.0</h2><p>A module method to pipe between streams forwarding errors and properly cleaning
up and provide a callback when the pipeline is complete.</p>
<pre><code class="lang-js">const { pipeline } = require(&#39;stream&#39;);
const fs = require(&#39;fs&#39;);
const zlib = require(&#39;zlib&#39;);

// Use the pipeline API to easily pipe a series of streams
// together and get notified when the pipeline is fully done.

// A pipeline to gzip a potentially huge tar file efficiently:

pipeline(
  fs.createReadStream(&#39;archive.tar&#39;),
  zlib.createGzip(),
  fs.createWriteStream(&#39;archive.tar.gz&#39;),
  (err) =&gt; {
    if (err) {
      console.error(&#39;Pipeline failed&#39;, err);
    } else {
      console.log(&#39;Pipeline succeeded&#39;);
    }
  }
);
</code></pre>
<p>The <code>pipeline</code> API is promisify&#39;able as well:</p>
<pre><code class="lang-js">const pipeline = util.promisify(stream.pipeline);

async function run() {
  await pipeline(
    fs.createReadStream(&#39;archive.tar&#39;),
    zlib.createGzip(),
    fs.createWriteStream(&#39;archive.tar.gz&#39;)
  );
  console.log(&#39;Pipeline succeeded&#39;);
}

run().catch(console.error);
</code></pre>
<h2>\_read - v10.0.0</h2><p>This function MUST NOT be called by application code directly. It should be
implemented by child classes, and called by the internal <code>Readable</code> class
methods only.</p>
<p>All <code>Readable</code> stream implementations must provide an implementation of the
<code>readable._read()</code> method to fetch data from the underlying resource.</p>
<p>When <code>readable._read()</code> is called, if data is available from the resource, the
implementation should begin pushing that data into the read queue using the
<a href="#stream_readable_push_chunk_encoding"><code>this.push(dataChunk)</code></a> method. <code>_read()</code> should continue reading
from the resource and pushing data until <code>readable.push()</code> returns <code>false</code>. Only
when <code>_read()</code> is called again after it has stopped should it resume pushing
additional data onto the queue.</p>
<p>Once the <code>readable._read()</code> method has been called, it will not be called again
until the <a href="#stream_readable_push_chunk_encoding"><code>readable.push()</code></a> method is called. <code>readable._read()</code>
is guaranteed to be called only once within a synchronous execution, i.e. a
microtick.</p>
<p>The <code>size</code> argument is advisory. For implementations where a &quot;read&quot; is a
single operation that returns data can use the <code>size</code> argument to determine how
much data to fetch. Other implementations may ignore this argument and simply
provide data whenever it becomes available. There is no need to &quot;wait&quot; until
<code>size</code> bytes are available before calling <a href="#stream_readable_push_chunk_encoding"><code>stream.push(chunk)</code></a>.</p>
<p>The <code>readable._read()</code> method is prefixed with an underscore because it is
internal to the class that defines it, and should never be called directly by
user programs.</p>
<h2>finished - v10.0.0</h2><p>A function to get notified when a stream is no longer readable, writable
or has experienced an error or a premature close event.</p>
<pre><code class="lang-js">const { finished } = require(&#39;stream&#39;);

const rs = fs.createReadStream(&#39;archive.tar&#39;);

finished(rs, (err) =&gt; {
  if (err) {
    console.error(&#39;Stream failed&#39;, err);
  } else {
    console.log(&#39;Stream is done reading&#39;);
  }
});

rs.resume(); // drain the stream
</code></pre>
<p>Especially useful in error handling scenarios where a stream is destroyed
prematurely (like an aborted HTTP request), and will not emit <code>&#39;end&#39;</code>
or <code>&#39;finish&#39;</code>.</p>
<p>The <code>finished</code> API is promisify&#39;able as well;</p>
<pre><code class="lang-js">const finished = util.promisify(stream.finished);

const rs = fs.createReadStream(&#39;archive.tar&#39;);

async function run() {
  await finished(rs);
  console.log(&#39;Stream is done reading&#39;);
}

run().catch(console.error);
rs.resume(); // drain the stream
</code></pre>
<h2>pipeline - v10.0.0</h2><p>A module method to pipe between streams forwarding errors and properly cleaning
up and provide a callback when the pipeline is complete.</p>
<pre><code class="lang-js">const { pipeline } = require(&#39;stream&#39;);
const fs = require(&#39;fs&#39;);
const zlib = require(&#39;zlib&#39;);

// Use the pipeline API to easily pipe a series of streams
// together and get notified when the pipeline is fully done.

// A pipeline to gzip a potentially huge tar file efficiently:

pipeline(
  fs.createReadStream(&#39;archive.tar&#39;),
  zlib.createGzip(),
  fs.createWriteStream(&#39;archive.tar.gz&#39;),
  (err) =&gt; {
    if (err) {
      console.error(&#39;Pipeline failed&#39;, err);
    } else {
      console.log(&#39;Pipeline succeeded&#39;);
    }
  }
);
</code></pre>
<p>The <code>pipeline</code> API is promisify&#39;able as well:</p>
<pre><code class="lang-js">const pipeline = util.promisify(stream.pipeline);

async function run() {
  await pipeline(
    fs.createReadStream(&#39;archive.tar&#39;),
    zlib.createGzip(),
    fs.createWriteStream(&#39;archive.tar.gz&#39;)
  );
  console.log(&#39;Pipeline succeeded&#39;);
}

run().catch(console.error);
</code></pre>
<h2>ref - v9.7.0</h2><p>When called, requests that the Node.js event loop <em>not</em> exit so long as the
<code>Immediate</code> is active. Calling <code>immediate.ref()</code> multiple times will have no
effect.</p>
<p>By default, all <code>Immediate</code> objects are &quot;ref&#39;ed&quot;, making it normally unnecessary
to call <code>immediate.ref()</code> unless <code>immediate.unref()</code> had been called previously.</p>
<h2>unref - v9.7.0</h2><p>When called, the active <code>Immediate</code> object will not require the Node.js event
loop to remain active. If there is no other activity keeping the event loop
running, the process may exit before the <code>Immediate</code> object&#39;s callback is
invoked. Calling <code>immediate.unref()</code> multiple times will have no effect.</p>
<h2>refresh - v10.2.0</h2><p>Sets the timer&#39;s start time to the current time, and reschedules the timer to
call its callback at the previously specified duration adjusted to the current
time. This is useful for refreshing a timer without allocating a new
JavaScript object.</p>
<p>Using this on a timer that has already called its callback will reactivate the
timer.</p>
<h2>getFinished - v9.9.0</h2><p>As the <code>Finished</code> messages are message digests of the complete handshake
(with a total of 192 bits for TLS 1.0 and more for SSL 3.0), they can
be used for external authentication procedures when the authentication
provided by SSL/TLS is not desired or is not enough.</p>
<p>Corresponds to the <code>SSL_get_finished</code> routine in OpenSSL and may be used
to implement the <code>tls-unique</code> channel binding from <a href="https://tools.ietf.org/html/rfc5929">RFC 5929</a>.</p>
<h2>getPeerFinished - v9.9.0</h2><p>As the <code>Finished</code> messages are message digests of the complete handshake
(with a total of 192 bits for TLS 1.0 and more for SSL 3.0), they can
be used for external authentication procedures when the authentication
provided by SSL/TLS is not desired or is not enough.</p>
<p>Corresponds to the <code>SSL_get_peer_finished</code> routine in OpenSSL and may be used
to implement the <code>tls-unique</code> channel binding from <a href="https://tools.ietf.org/html/rfc5929">RFC 5929</a>.</p>
<h2>createSecureContext - v9.3.0</h2><p><a href="#tls_tls_createserver_options_secureconnectionlistener"><code>tls.createServer()</code></a> sets the default value of the <code>honorCipherOrder</code> option
to <code>true</code>, other APIs that create secure contexts leave it unset.</p>
<p><a href="#tls_tls_createserver_options_secureconnectionlistener"><code>tls.createServer()</code></a> uses a 128 bit truncated SHA1 hash value generated
from <code>process.argv</code> as the default value of the <code>sessionIdContext</code> option, other
APIs that create secure contexts have no default value.</p>
<p>The <code>tls.createSecureContext()</code> method creates a credentials object.</p>
<p>A key is <em>required</em> for ciphers that make use of certificates. Either <code>key</code> or
<code>pfx</code> can be used to provide it.</p>
<p>If the &#39;ca&#39; option is not given, then Node.js will use the default
publicly trusted list of CAs as given in
<a href="https://hg.mozilla.org/mozilla-central/raw-file/tip/security/nss/lib/ckfw/builtins/certdata.txt">https://hg.mozilla.org/mozilla-central/raw-file/tip/security/nss/lib/ckfw/builtins/certdata.txt</a>.</p>
<h2>createServer - v9.3.0</h2><p>Creates a new <a href="#tls_class_tls_server"><code>tls.Server</code></a>. The <code>secureConnectionListener</code>, if provided, is
automatically set as a listener for the <a href="#tls_event_secureconnection"><code>&#39;secureConnection&#39;</code></a> event.</p>
<p>The <code>ticketKeys</code> options is automatically shared between <code>cluster</code> module
workers.</p>
<p>The following illustrates a simple echo server:</p>
<pre><code class="lang-js">const tls = require(&#39;tls&#39;);
const fs = require(&#39;fs&#39;);

const options = {
  key: fs.readFileSync(&#39;server-key.pem&#39;),
  cert: fs.readFileSync(&#39;server-cert.pem&#39;),

  // This is necessary only if using the client certificate authentication.
  requestCert: true,

  // This is necessary only if the client uses the self-signed certificate.
  ca: [ fs.readFileSync(&#39;client-cert.pem&#39;) ]
};

const server = tls.createServer(options, (socket) =&gt; {
  console.log(&#39;server connected&#39;,
              socket.authorized ? &#39;authorized&#39; : &#39;unauthorized&#39;);
  socket.write(&#39;welcome!\n&#39;);
  socket.setEncoding(&#39;utf8&#39;);
  socket.pipe(socket);
});
server.listen(8000, () =&gt; {
  console.log(&#39;server bound&#39;);
});
</code></pre>
<p>Or</p>
<pre><code class="lang-js">const tls = require(&#39;tls&#39;);
const fs = require(&#39;fs&#39;);

const options = {
  pfx: fs.readFileSync(&#39;server.pfx&#39;),

  // This is necessary only if using the client certificate authentication.
  requestCert: true,
};

const server = tls.createServer(options, (socket) =&gt; {
  console.log(&#39;server connected&#39;,
              socket.authorized ? &#39;authorized&#39; : &#39;unauthorized&#39;);
  socket.write(&#39;welcome!\n&#39;);
  socket.setEncoding(&#39;utf8&#39;);
  socket.pipe(socket);
});
server.listen(8000, () =&gt; {
  console.log(&#39;server bound&#39;);
});
</code></pre>
<p>This server can be tested by connecting to it using <code>openssl s_client</code>:</p>
<pre><code class="lang-sh">openssl s_client -connect 127.0.0.1:8000
</code></pre>
<h2>the_`trace_events`_module - v10.0.0</h2>undefined<h2>`tracing`_object - v10.0.0</h2><p>The <code>Tracing</code> object is used to enable or disable tracing for sets of
categories. Instances are created using the <code>trace_events.createTracing()</code>
method.</p>
<p>When created, the <code>Tracing</code> object is disabled. Calling the
<code>tracing.enable()</code> method adds the categories to the set of enabled trace event
categories. Calling <code>tracing.disable()</code> will remove the categories from the
set of enabled trace event categories.</p>
<h2>`tracing.categories` - v10.0.0</h2><ul>
<li>{string}</li>
</ul>
<p>A comma-separated list of the trace event categories covered by this
<code>Tracing</code> object.</p>
<h2>`tracing.disable()` - v10.0.0</h2><p>Disables this <code>Tracing</code> object.</p>
<p>Only trace event categories <em>not</em> covered by other enabled <code>Tracing</code> objects
and <em>not</em> specified by the <code>--trace-event-categories</code> flag will be disabled.</p>
<pre><code class="lang-js">const trace_events = require(&#39;trace_events&#39;);
const t1 = trace_events.createTracing({ categories: [&#39;node&#39;, &#39;v8&#39;] });
const t2 = trace_events.createTracing({ categories: [&#39;node.perf&#39;, &#39;node&#39;] });
t1.enable();
t2.enable();

// Prints &#39;node,node.perf,v8&#39;
console.log(trace_events.getEnabledCategories());

t2.disable(); // will only disable emission of the &#39;node.perf&#39; category

// Prints &#39;node,v8&#39;
console.log(trace_events.getEnabledCategories());
</code></pre>
<h2>`tracing.enable()` - v10.0.0</h2><p>Enables this <code>Tracing</code> object for the set of categories covered by the
<code>Tracing</code> object.</p>
<h2>`tracing.enabled` - v10.0.0</h2><ul>
<li>{boolean} <code>true</code> only if the <code>Tracing</code> object has been enabled.</li>
</ul>
<h2>`trace_events.createtracing(options)` - v10.0.0</h2><ul>
<li><code>options</code> {Object}<ul>
<li><code>categories</code> {string[]} An array of trace category names. Values included
in the array are coerced to a string when possible. An error will be
thrown if the value cannot be coerced.</li>
</ul>
</li>
<li>Returns: {Tracing}.</li>
</ul>
<p>Creates and returns a <code>Tracing</code> object for the given set of <code>categories</code>.</p>
<pre><code class="lang-js">const trace_events = require(&#39;trace_events&#39;);
const categories = [&#39;node.perf&#39;, &#39;node.async_hooks&#39;];
const tracing = trace_events.createTracing({ categories });
tracing.enable();
// do stuff
tracing.disable();
</code></pre>
<h2>`trace_events.getenabledcategories()` - v10.0.0</h2><ul>
<li>Returns: {string}</li>
</ul>
<p>Returns a comma-separated list of all currently-enabled trace event
categories. The current set of enabled trace event categories is determined
by the <em>union</em> of all currently-enabled <code>Tracing</code> objects and any categories
enabled using the <code>--trace-event-categories</code> flag.</p>
<p>Given the file <code>test.js</code> below, the command
<code>node --trace-event-categories node.perf test.js</code> will print
<code>&#39;node.async_hooks,node.perf&#39;</code> to the console.</p>
<pre><code class="lang-js">const trace_events = require(&#39;trace_events&#39;);
const t1 = trace_events.createTracing({ categories: [&#39;node.async_hooks&#39;] });
const t2 = trace_events.createTracing({ categories: [&#39;node.perf&#39;] });
const t3 = trace_events.createTracing({ categories: [&#39;v8&#39;] });

t1.enable();
t2.enable();

console.log(trace_events.getEnabledCategories());
</code></pre>
<!-- [end-include:tracing.md] -->
<!-- [start-include:tty.md] -->
<h2>getColorDepth - v9.9.0</h2><p>Returns:</p>
<ul>
<li><code>1</code> for 2,</li>
<li><code>4</code> for 16,</li>
<li><code>8</code> for 256,</li>
<li><code>24</code> for 16,777,216
colors supported.</li>
</ul>
<p>Use this to determine what colors the terminal supports. Due to the nature of
colors in terminals it is possible to either have false positives or false
negatives. It depends on process information and the environment variables that
may lie about what terminal is used.
To enforce a specific behavior without relying on <code>process.env</code> it is possible
to pass in an object with different settings.</p>
<p>Use the <code>NODE_DISABLE_COLORS</code> environment variable to enforce this function to
always return 1.</p>
<h2>URL - v10.0.0</h2><p>Browser-compatible <code>URL</code> class, implemented by following the WHATWG URL
Standard. <a href="https://url.spec.whatwg.org/#example-url-parsing">Examples of parsed URLs</a> may be found in the Standard itself.
The <code>URL</code> class is also available on the global object.</p>
<p>In accordance with browser conventions, all properties of <code>URL</code> objects
are implemented as getters and setters on the class prototype, rather than as
data properties on the object itself. Thus, unlike <a href="#url_legacy_urlobject">legacy <code>urlObject</code></a>s,
using the <code>delete</code> keyword on any properties of <code>URL</code> objects (e.g. <code>delete
myURL.protocol</code>, <code>delete myURL.pathname</code>, etc) has no effect but will still
return <code>true</code>.</p>
<h2>URLSearchParams - v10.0.0</h2><p>The <code>URLSearchParams</code> API provides read and write access to the query of a
<code>URL</code>. The <code>URLSearchParams</code> class can also be used standalone with one of the
four following constructors.
The <code>URLSearchParams</code> class is also available on the global object.</p>
<p>The WHATWG <code>URLSearchParams</code> interface and the <a href="querystring.html"><code>querystring</code></a> module have
similar purpose, but the purpose of the <a href="querystring.html"><code>querystring</code></a> module is more
general, as it allows the customization of delimiter characters (<code>&amp;</code> and <code>=</code>).
On the other hand, this API is designed purely for URL query strings.</p>
<pre><code class="lang-js">const myURL = new URL(&#39;https://example.org/?abc=123&#39;);
console.log(myURL.searchParams.get(&#39;abc&#39;));
// Prints 123

myURL.searchParams.append(&#39;abc&#39;, &#39;xyz&#39;);
console.log(myURL.href);
// Prints https://example.org/?abc=123&amp;abc=xyz

myURL.searchParams.delete(&#39;abc&#39;);
myURL.searchParams.set(&#39;a&#39;, &#39;b&#39;);
console.log(myURL.href);
// Prints https://example.org/?a=b

const newSearchParams = new URLSearchParams(myURL.searchParams);
// The above is equivalent to
// const newSearchParams = new URLSearchParams(myURL.search);

newSearchParams.append(&#39;a&#39;, &#39;c&#39;);
console.log(myURL.href);
// Prints https://example.org/?a=b
console.log(newSearchParams.toString());
// Prints a=b&amp;a=c

// newSearchParams.toString() is implicitly called
myURL.search = newSearchParams;
console.log(myURL.href);
// Prints https://example.org/?a=b&amp;a=c
newSearchParams.delete(&#39;a&#39;);
console.log(myURL.href);
// Prints https://example.org/?a=b&amp;a=c
</code></pre>
<h2>deprecate - v10.0.0</h2><p>The <code>util.deprecate()</code> method wraps <code>fn</code> (which may be a function or class) in
such a way that it is marked as deprecated.</p>
<pre><code class="lang-js">const util = require(&#39;util&#39;);

exports.obsoleteFunction = util.deprecate(() =&gt; {
  // Do something here.
}, &#39;obsoleteFunction() is deprecated. Use newShinyFunction() instead.&#39;);
</code></pre>
<p>When called, <code>util.deprecate()</code> will return a function that will emit a
<code>DeprecationWarning</code> using the <a href="process.html#process_event_warning"><code>&#39;warning&#39;</code></a> event. The warning will
be emitted and printed to <code>stderr</code> the first time the returned function is
called. After the warning is emitted, the wrapped function is called without
emitting a warning.</p>
<p>If the same optional <code>code</code> is supplied in multiple calls to <code>util.deprecate()</code>,
the warning will be emitted only once for that <code>code</code>.</p>
<pre><code class="lang-js">const util = require(&#39;util&#39;);

const fn1 = util.deprecate(someFunction, someMessage, &#39;DEP0001&#39;);
const fn2 = util.deprecate(someOtherFunction, someOtherMessage, &#39;DEP0001&#39;);
fn1(); // emits a deprecation warning with code DEP0001
fn2(); // does not emit a deprecation warning because it has the same code
</code></pre>
<p>If either the <code>--no-deprecation</code> or <code>--no-warnings</code> command line flags are
used, or if the <code>process.noDeprecation</code> property is set to <code>true</code> <em>prior</em> to
the first deprecation warning, the <code>util.deprecate()</code> method does nothing.</p>
<p>If the <code>--trace-deprecation</code> or <code>--trace-warnings</code> command line flags are set,
or the <code>process.traceDeprecation</code> property is set to <code>true</code>, a warning and a
stack trace are printed to <code>stderr</code> the first time the deprecated function is
called.</p>
<p>If the <code>--throw-deprecation</code> command line flag is set, or the
<code>process.throwDeprecation</code> property is set to <code>true</code>, then an exception will be
thrown when the deprecated function is called.</p>
<p>The <code>--throw-deprecation</code> command line flag and <code>process.throwDeprecation</code>
property take precedence over <code>--trace-deprecation</code> and
<code>process.traceDeprecation</code>.</p>
<h2>formatWithOptions - v10.0.0</h2><p>This function is identical to <a href="#util_util_format_format_args"><code>util.format()</code></a>, except in that it takes
an <code>inspectOptions</code> argument which specifies options that are passed along to
<a href="#util_util_inspect_object_options"><code>util.inspect()</code></a>.</p>
<pre><code class="lang-js">util.formatWithOptions({ colors: true }, &#39;See object %O&#39;, { foo: 42 });
// Returns &#39;See object { foo: 42 }&#39;, where `42` is colored as a number
// when printed to a terminal.
</code></pre>
<h2>getSystemErrorName - v9.7.0</h2><p>Returns the string name for a numeric error code that comes from a Node.js API.
The mapping between error codes and error names is platform-dependent.
See <a href="errors.html#errors_common_system_errors">Common System Errors</a> for the names of common errors.</p>
<pre><code class="lang-js">fs.access(&#39;file/that/does/not/exist&#39;, (err) =&gt; {
  const name = util.getSystemErrorName(err.errno);
  console.error(name);  // ENOENT
});
</code></pre>
<h2>inspect - v10.0.0</h2><p>The <code>util.inspect()</code> method returns a string representation of <code>object</code> that is
intended for debugging. The output of <code>util.inspect</code> may change at any time
and should not be depended upon programmatically. Additional <code>options</code> may be
passed that alter certain aspects of the formatted string.
<code>util.inspect()</code> will use the constructor&#39;s name and/or <code>@@toStringTag</code> to make
an identifiable tag for an inspected value.</p>
<pre><code class="lang-js">class Foo {
  get [Symbol.toStringTag]() {
    return &#39;bar&#39;;
  }
}

class Bar {}

const baz = Object.create(null, { [Symbol.toStringTag]: { value: &#39;foo&#39; } });

util.inspect(new Foo()); // &#39;Foo [bar] {}&#39;
util.inspect(new Bar()); // &#39;Bar {}&#39;
util.inspect(baz);       // &#39;[foo] {}&#39;
</code></pre>
<p>The following example inspects all properties of the <code>util</code> object:</p>
<pre><code class="lang-js">const util = require(&#39;util&#39;);

console.log(util.inspect(util, { showHidden: true, depth: null }));
</code></pre>
<p>Values may supply their own custom <code>inspect(depth, opts)</code> functions, when
called these receive the current <code>depth</code> in the recursive inspection, as well as
the options object passed to <code>util.inspect()</code>.</p>
<p>The following example highlights the difference with the <code>compact</code> option:</p>
<pre><code class="lang-js">const util = require(&#39;util&#39;);

const o = {
  a: [1, 2, [[
    &#39;Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do &#39; +
      &#39;eiusmod tempor incididunt ut labore et dolore magna aliqua.&#39;,
    &#39;test&#39;,
    &#39;foo&#39;]], 4],
  b: new Map([[&#39;za&#39;, 1], [&#39;zb&#39;, &#39;test&#39;]])
};
console.log(util.inspect(o, { compact: true, depth: 5, breakLength: 80 }));

// This will print

// { a:
//   [ 1,
//     2,
//     [ [ &#39;Lorem ipsum dolor sit amet, consectetur [...]&#39;, // A long line
//           &#39;test&#39;,
//           &#39;foo&#39; ] ],
//     4 ],
//   b: Map { &#39;za&#39; =&gt; 1, &#39;zb&#39; =&gt; &#39;test&#39; } }

// Setting `compact` to false changes the output to be more reader friendly.
console.log(util.inspect(o, { compact: false, depth: 5, breakLength: 80 }));

// {
//   a: [
//     1,
//     2,
//     [
//       [
//         &#39;Lorem ipsum dolor sit amet, consectetur &#39; +
//           &#39;adipiscing elit, sed do eiusmod tempor &#39; +
//           &#39;incididunt ut labore et dolore magna &#39; +
//           &#39;aliqua.,
//         &#39;test&#39;,
//         &#39;foo&#39;
//       ]
//     ],
//     4
//   ],
//   b: Map {
//     &#39;za&#39; =&gt; 1,
//     &#39;zb&#39; =&gt; &#39;test&#39;
//   }
// }

// Setting `breakLength` to e.g. 150 will print the &quot;Lorem ipsum&quot; text in a
// single line.
// Reducing the `breakLength` will split the &quot;Lorem ipsum&quot; text in smaller
// chunks.
</code></pre>
<p>Using the <code>showHidden</code> option allows to inspect <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap"><code>WeakMap</code></a> and <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakSet"><code>WeakSet</code></a>
entries. If there are more entries than <code>maxArrayLength</code>, there is no guarantee
which entries are displayed. That means retrieving the same <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakSet"><code>WeakSet</code></a>
entries twice might actually result in a different output. Besides this any item
might be collected at any point of time by the garbage collector if there is no
strong reference left to that object. Therefore there is no guarantee to get a
reliable output.</p>
<pre><code class="lang-js">const { inspect } = require(&#39;util&#39;);

const obj = { a: 1 };
const obj2 = { b: 2 };
const weakSet = new WeakSet([obj, obj2]);

console.log(inspect(weakSet, { showHidden: true }));
// WeakSet { { a: 1 }, { b: 2 } }
</code></pre>
<p>Please note that <code>util.inspect()</code> is a synchronous method that is mainly
intended as a debugging tool. Some input values can have a significant
performance overhead that can block the event loop. Use this function
with care and never in a hot code path.</p>
<h2>vm.Module - v9.6.0</h2><p><em>This feature is only available with the <code>--experimental-vm-modules</code> command
flag enabled.</em></p>
<p>The <code>vm.Module</code> class provides a low-level interface for using ECMAScript
modules in VM contexts. It is the counterpart of the <code>vm.Script</code> class that
closely mirrors <a href="https://tc39.github.io/ecma262/#sec-source-text-module-records">Source Text Module Record</a>s as defined in the ECMAScript
specification.</p>
<p>Unlike <code>vm.Script</code> however, every <code>vm.Module</code> object is bound to a context from
its creation. Operations on <code>vm.Module</code> objects are intrinsically asynchronous,
in contrast with the synchronous nature of <code>vm.Script</code> objects. With the help
of async functions, however, manipulating <code>vm.Module</code> objects is fairly
straightforward.</p>
<p>Using a <code>vm.Module</code> object requires four distinct steps: creation/parsing,
linking, instantiation, and evaluation. These four steps are illustrated in the
following example.</p>
<p>This implementation lies at a lower level than the <a href="esm.html#esm_ecmascript_modules">ECMAScript Module
loader</a>. There is also currently no way to interact with the Loader, though
support is planned.</p>
<pre><code class="lang-js">const vm = require(&#39;vm&#39;);

const contextifiedSandbox = vm.createContext({ secret: 42 });

(async () =&gt; {
  // Step 1
  //
  // Create a Module by constructing a new `vm.Module` object. This parses the
  // provided source text, throwing a `SyntaxError` if anything goes wrong. By
  // default, a Module is created in the top context. But here, we specify
  // `contextifiedSandbox` as the context this Module belongs to.
  //
  // Here, we attempt to obtain the default export from the module &quot;foo&quot;, and
  // put it into local binding &quot;secret&quot;.

  const bar = new vm.Module(`
    import s from &#39;foo&#39;;
    s;
  `, { context: contextifiedSandbox });

  // Step 2
  //
  // &quot;Link&quot; the imported dependencies of this Module to it.
  //
  // The provided linking callback (the &quot;linker&quot;) accepts two arguments: the
  // parent module (`bar` in this case) and the string that is the specifier of
  // the imported module. The callback is expected to return a Module that
  // corresponds to the provided specifier, with certain requirements documented
  // in `module.link()`.
  //
  // If linking has not started for the returned Module, the same linker
  // callback will be called on the returned Module.
  //
  // Even top-level Modules without dependencies must be explicitly linked. The
  // callback provided would never be called, however.
  //
  // The link() method returns a Promise that will be resolved when all the
  // Promises returned by the linker resolve.
  //
  // Note: This is a contrived example in that the linker function creates a new
  // &quot;foo&quot; module every time it is called. In a full-fledged module system, a
  // cache would probably be used to avoid duplicated modules.

  async function linker(specifier, referencingModule) {
    if (specifier === &#39;foo&#39;) {
      return new vm.Module(`
        // The &quot;secret&quot; variable refers to the global variable we added to
        // &quot;contextifiedSandbox&quot; when creating the context.
        export default secret;
      `, { context: referencingModule.context });

      // Using `contextifiedSandbox` instead of `referencingModule.context`
      // here would work as well.
    }
    throw new Error(`Unable to resolve dependency: ${specifier}`);
  }
  await bar.link(linker);

  // Step 3
  //
  // Instantiate the top-level Module.
  //
  // Only the top-level Module needs to be explicitly instantiated; its
  // dependencies will be recursively instantiated by instantiate().

  bar.instantiate();

  // Step 4
  //
  // Evaluate the Module. The evaluate() method returns a Promise with a single
  // property &quot;result&quot; that contains the result of the very last statement
  // executed in the Module. In the case of `bar`, it is `s;`, which refers to
  // the default export of the `foo` module, the `secret` we set in the
  // beginning to 42.

  const { result } = await bar.evaluate();

  console.log(result);
  // Prints 42.
})();
</code></pre>
<h2>runInNewContext - v10.0.0</h2><p>First contextifies the given <code>sandbox</code>, runs the compiled code contained by
the <code>vm.Script</code> object within the created sandbox, and returns the result.
Running code does not have access to local scope.</p>
<p>The following example compiles code that sets a global variable, then executes
the code multiple times in different contexts. The globals are set on and
contained within each individual <code>sandbox</code>.</p>
<pre><code class="lang-js">const util = require(&#39;util&#39;);
const vm = require(&#39;vm&#39;);

const script = new vm.Script(&#39;globalVar = &quot;set&quot;&#39;);

const sandboxes = [{}, {}, {}];
sandboxes.forEach((sandbox) =&gt; {
  script.runInNewContext(sandbox);
});

console.log(util.inspect(sandboxes));

// [{ globalVar: &#39;set&#39; }, { globalVar: &#39;set&#39; }, { globalVar: &#39;set&#39; }]
</code></pre>
<h2>createContext - v10.0.0</h2><p>If given a <code>sandbox</code> object, the <code>vm.createContext()</code> method will <a href="#vm_what_does_it_mean_to_contextify_an_object">prepare
that sandbox</a> so that it can be used in calls to
<a href="#vm_vm_runincontext_code_contextifiedsandbox_options"><code>vm.runInContext()</code></a> or <a href="#vm_script_runincontext_contextifiedsandbox_options"><code>script.runInContext()</code></a>. Inside such scripts,
the <code>sandbox</code> object will be the global object, retaining all of its existing
properties but also having the built-in objects and functions any standard
<a href="https://es5.github.io/#x15.1">global object</a> has. Outside of scripts run by the vm module, global variables
will remain unchanged.</p>
<pre><code class="lang-js">const util = require(&#39;util&#39;);
const vm = require(&#39;vm&#39;);

global.globalVar = 3;

const sandbox = { globalVar: 1 };
vm.createContext(sandbox);

vm.runInContext(&#39;globalVar *= 2;&#39;, sandbox);

console.log(util.inspect(sandbox)); // { globalVar: 2 }

console.log(util.inspect(globalVar)); // 3
</code></pre>
<p>If <code>sandbox</code> is omitted (or passed explicitly as <code>undefined</code>), a new, empty
<a href="#vm_what_does_it_mean_to_contextify_an_object">contextified</a> sandbox object will be returned.</p>
<p>The <code>vm.createContext()</code> method is primarily useful for creating a single
sandbox that can be used to run multiple scripts. For instance, if emulating a
web browser, the method can be used to create a single sandbox representing a
window&#39;s global object, then run all <code>&lt;script&gt;</code> tags together within the context
of that sandbox.</p>
<p>The provided <code>name</code> and <code>origin</code> of the context are made visible through the
Inspector API.</p>
<h2>Options - v9.4.0</h2><p>Each class takes an <code>options</code> object. All options are optional.</p>
<p>Note that some options are only relevant when compressing, and are
ignored by the decompression classes.</p>
<ul>
<li><code>flush</code> {integer} <strong>Default:</strong> <code>zlib.constants.Z_NO_FLUSH</code></li>
<li><code>finishFlush</code> {integer} <strong>Default:</strong> <code>zlib.constants.Z_FINISH</code></li>
<li><code>chunkSize</code> {integer} <strong>Default:</strong> <code>16 * 1024</code></li>
<li><code>windowBits</code> {integer}</li>
<li><code>level</code> {integer} (compression only)</li>
<li><code>memLevel</code> {integer} (compression only)</li>
<li><code>strategy</code> {integer} (compression only)</li>
<li><code>dictionary</code> {Buffer|TypedArray|DataView|ArrayBuffer} (deflate/inflate only,
empty dictionary by default)</li>
<li><code>info</code> {boolean} (If <code>true</code>, returns an object with <code>buffer</code> and <code>engine</code>.)</li>
</ul>
<p>See the description of <code>deflateInit2</code> and <code>inflateInit2</code> at
<a href="https://zlib.net/manual.html#Advanced">https://zlib.net/manual.html#Advanced</a> for more information on these.</p>
<h2>deflate - v9.4.0</h2><p>Compress a chunk of data with <a href="#zlib_class_zlib_deflate"><code>Deflate</code></a>.</p>
<h2>deflateSync - v9.4.0</h2><p>Compress a chunk of data with <a href="#zlib_class_zlib_deflate"><code>Deflate</code></a>.</p>
<h2>deflateRawSync - v9.4.0</h2><p>Compress a chunk of data with <a href="#zlib_class_zlib_deflateraw"><code>DeflateRaw</code></a>.</p>
<h2>gunzip - v9.4.0</h2><p>Decompress a chunk of data with <a href="#zlib_class_zlib_gunzip"><code>Gunzip</code></a>.</p>
<h2>gunzipSync - v9.4.0</h2><p>Decompress a chunk of data with <a href="#zlib_class_zlib_gunzip"><code>Gunzip</code></a>.</p>
<h2>gzip - v9.4.0</h2><p>Compress a chunk of data with <a href="#zlib_class_zlib_gzip"><code>Gzip</code></a>.</p>
<h2>gzipSync - v9.4.0</h2><p>Compress a chunk of data with <a href="#zlib_class_zlib_gzip"><code>Gzip</code></a>.</p>
<h2>inflate - v9.4.0</h2><p>Decompress a chunk of data with <a href="#zlib_class_zlib_inflate"><code>Inflate</code></a>.</p>
<h2>inflateSync - v9.4.0</h2><p>Decompress a chunk of data with <a href="#zlib_class_zlib_inflate"><code>Inflate</code></a>.</p>
<h2>inflateRaw - v9.4.0</h2><p>Decompress a chunk of data with <a href="#zlib_class_zlib_inflateraw"><code>InflateRaw</code></a>.</p>
<h2>inflateRawSync - v9.4.0</h2><p>Decompress a chunk of data with <a href="#zlib_class_zlib_inflateraw"><code>InflateRaw</code></a>.</p>
<h2>unzip - v9.4.0</h2><p>Decompress a chunk of data with <a href="#zlib_class_zlib_unzip"><code>Unzip</code></a>.</p>
<!-- [end-include:zlib.md] -->
<h2>unzipSync - v9.4.0</h2><p>Decompress a chunk of data with <a href="#zlib_class_zlib_unzip"><code>Unzip</code></a>.</p>
<!-- [end-include:zlib.md] -->
<h2>deflate - v9.4.0</h2><p>Compress a chunk of data with <a href="#zlib_class_zlib_deflate"><code>Deflate</code></a>.</p>
<h2>deflateSync - v9.4.0</h2><p>Compress a chunk of data with <a href="#zlib_class_zlib_deflate"><code>Deflate</code></a>.</p>
<h2>deflateRawSync - v9.4.0</h2><p>Compress a chunk of data with <a href="#zlib_class_zlib_deflateraw"><code>DeflateRaw</code></a>.</p>
<h2>gunzip - v9.4.0</h2><p>Decompress a chunk of data with <a href="#zlib_class_zlib_gunzip"><code>Gunzip</code></a>.</p>
<h2>gunzipSync - v9.4.0</h2><p>Decompress a chunk of data with <a href="#zlib_class_zlib_gunzip"><code>Gunzip</code></a>.</p>
<h2>gzip - v9.4.0</h2><p>Compress a chunk of data with <a href="#zlib_class_zlib_gzip"><code>Gzip</code></a>.</p>
<h2>gzipSync - v9.4.0</h2><p>Compress a chunk of data with <a href="#zlib_class_zlib_gzip"><code>Gzip</code></a>.</p>
<h2>inflate - v9.4.0</h2><p>Decompress a chunk of data with <a href="#zlib_class_zlib_inflate"><code>Inflate</code></a>.</p>
<h2>inflateSync - v9.4.0</h2><p>Decompress a chunk of data with <a href="#zlib_class_zlib_inflate"><code>Inflate</code></a>.</p>
<h2>inflateRaw - v9.4.0</h2><p>Decompress a chunk of data with <a href="#zlib_class_zlib_inflateraw"><code>InflateRaw</code></a>.</p>
<h2>inflateRawSync - v9.4.0</h2><p>Decompress a chunk of data with <a href="#zlib_class_zlib_inflateraw"><code>InflateRaw</code></a>.</p>
<h2>unzip - v9.4.0</h2><p>Decompress a chunk of data with <a href="#zlib_class_zlib_unzip"><code>Unzip</code></a>.</p>
<!-- [end-include:zlib.md] -->
<h2>unzipSync - v9.4.0</h2><p>Decompress a chunk of data with <a href="#zlib_class_zlib_unzip"><code>Unzip</code></a>.</p>
<!-- [end-include:zlib.md] -->
